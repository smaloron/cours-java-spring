<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-05-14T08:21:35.14344"><title>La gestion &eacute;v&eacute;nementielle | Spring</title><script type="application/json" id="virtual-toc-data">[{"id":"concepts-fondamentaux-applicationevent-et-applicationeventpublisher","level":0,"title":"Concepts Fondamentaux: ApplicationEvent et ApplicationEventPublisher","anchor":"#concepts-fondamentaux-applicationevent-et-applicationeventpublisher"},{"id":"gestion-des-v-nements-et-transactions-transactionaleventlistener","level":0,"title":"Gestion des Événements et Transactions: @TransactionalEventListener","anchor":"#gestion-des-v-nements-et-transactions-transactionaleventlistener"},{"id":"couteurs-d-entit-s-jpa-entitylisteners","level":0,"title":"Écouteurs d\u0027Entités JPA: @EntityListeners","anchor":"#couteurs-d-entit-s-jpa-entitylisteners"},{"id":"cas-d-utilisation-typiques-dans-une-application-web","level":0,"title":"Cas d\u0027Utilisation Typiques dans une Application Web","anchor":"#cas-d-utilisation-typiques-dans-une-application-web"},{"id":"bonnes-pratiques-et-conseils","level":0,"title":"Bonnes Pratiques et Conseils","anchor":"#bonnes-pratiques-et-conseils"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="La gestion &eacute;v&eacute;nementielle | Spring"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/030-00-la-gestion-evenementielle.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="La gestion &eacute;v&eacute;nementielle | Spring"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/030-00-la-gestion-evenementielle.html#webpage",
    "url": "writerside-documentation/030-00-la-gestion-evenementielle.html",
    "name": "La gestion &eacute;v&eacute;nementielle | Spring",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Help"
}</script><!-- End Schema.org --></head><body data-id="030-00-La-gestion-evenementielle" data-main-title="La gestion événementielle" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="030-00-La-gestion-evenementielle" id="030-00-La-gestion-evenementielle.md">La gestion événementielle</h1><p id="-a0k1zx_3">Dans une application, en particulier une application web, de nombreuses actions peuvent n&eacute;cessiter des traitements secondaires ou des notifications. Par exemple, apr&egrave;s l'inscription d'un utilisateur, il peut &ecirc;tre n&eacute;cessaire d'envoyer un email de bienvenue, de mettre &agrave; jour des statistiques ou d'initialiser un profil.</p><p id="-a0k1zx_4">Le syst&egrave;me d'&eacute;v&eacute;nements de Spring fournit un m&eacute;canisme bas&eacute; sur le pattern <span class="control" id="-a0k1zx_12">Observer</span> pour d&eacute;coupler les composants. Un composant (le <span class="emphasis" id="-a0k1zx_13">publisher</span> ou &eacute;metteur) publie un &eacute;v&eacute;nement lorsqu'une action sp&eacute;cifique se produit, et d'autres composants (les <span class="emphasis" id="-a0k1zx_14">listeners</span> ou &eacute;couteurs) peuvent r&eacute;agir &agrave; cet &eacute;v&eacute;nement sans que l'&eacute;metteur ait besoin de les conna&icirc;tre directement.</p><p id="-a0k1zx_5">Ce d&eacute;couplage am&eacute;liore la maintenabilit&eacute;, la testabilit&eacute; et la flexibilit&eacute; de l'application. Dans un contexte web, cela permet de s&eacute;parer la logique principale du contr&ocirc;leur ou du service des t&acirc;ches annexes.</p><section class="chapter"><h2 id="concepts-fondamentaux-applicationevent-et-applicationeventpublisher" data-toc="concepts-fondamentaux-applicationevent-et-applicationeventpublisher">Concepts Fondamentaux: <code class="code" id="-a0k1zx_20">ApplicationEvent</code> et <code class="code" id="-a0k1zx_21">ApplicationEventPublisher</code></h2><section class="chapter"><h3 id="applicationevent" data-toc="applicationevent"><code class="code" id="-a0k1zx_25">ApplicationEvent</code></h3><ul class="list _bullet" id="-a0k1zx_23"><li class="list__item" id="-a0k1zx_26"><p id="-a0k1zx_28"><span class="control" id="-a0k1zx_29">D&eacute;finition:</span> Toute action ou &eacute;tat significatif dans l'application peut &ecirc;tre repr&eacute;sent&eacute; par un &eacute;v&eacute;nement. Dans Spring, les &eacute;v&eacute;nements personnalis&eacute;s doivent h&eacute;riter de la classe <code class="code" id="-a0k1zx_30">ApplicationEvent</code>.</p></li><li class="list__item" id="-a0k1zx_27"><p id="-a0k1zx_31"><span class="control" id="-a0k1zx_32">Cr&eacute;ation d'un &Eacute;v&eacute;nement Personnalis&eacute;&nbsp;:</span> Pour cr&eacute;er un &eacute;v&eacute;nement sp&eacute;cifique, on &eacute;tend <code class="code" id="-a0k1zx_33">ApplicationEvent</code>. L'&eacute;v&eacute;nement peut transporter des donn&eacute;es pertinentes concernant ce qui s'est pass&eacute;. Il est recommand&eacute; de rendre les objets &eacute;v&eacute;nements <span class="control" id="-a0k1zx_34">immutables</span>.</p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.event;

import org.springframework.context.ApplicationEvent;
// Importe l'entité ou le DTO pertinent si nécessaire
import fr.formation.spring.user.UserAccount; // Supposons une classe UserAccount

/**
 * Événement déclenché lors de la création réussie d'un compte utilisateur.
 * Il hérite de ApplicationEvent et transporte l'objet UserAccount créé.
 */
public class UserCreationEvent extends ApplicationEvent {

    private final UserAccount userAccount; // Données liées à l'événement

    /**
     * Constructeur de l'événement.
     * @param source L'objet sur lequel l'événement s'est initialement produit
     *               (généralement le composant qui publie l'événement).
     * @param userAccount L'objet UserAccount qui vient d'être créé.
     */
    public UserCreationEvent(Object source, UserAccount userAccount) {
        super(source);
        this.userAccount = userAccount;
    }

    /**
     * Getter pour accéder aux données de l'événement 
     * (l'utilisateur créé).
     * @return Le compte utilisateur associé à cet événement.
     */
    public UserAccount getUserAccount() {
        return userAccount;
    }
}
</div></section><section class="chapter"><h3 id="applicationeventpublisher" data-toc="applicationeventpublisher"><code class="code" id="-a0k1zx_38">ApplicationEventPublisher</code></h3><ul class="list _bullet" id="-a0k1zx_36"><li class="list__item" id="-a0k1zx_39"><p id="-a0k1zx_41"><span class="control" id="-a0k1zx_42">D&eacute;finition:</span> C'est une interface Spring qui permet de publier des &eacute;v&eacute;nements. Les beans Spring peuvent obtenir une instance de <code class="code" id="-a0k1zx_43">ApplicationEventPublisher</code> par injection de d&eacute;pendances.</p></li><li class="list__item" id="-a0k1zx_40"><p id="-a0k1zx_44"><span class="control" id="-a0k1zx_45">Publication d'un &Eacute;v&eacute;nement:</span> Pour publier un &eacute;v&eacute;nement, on appelle la m&eacute;thode <code class="code" id="-a0k1zx_46">publishEvent()</code> de l'instance <code class="code" id="-a0k1zx_47">ApplicationEventPublisher</code>.</p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
// Importe l'entité ou le DTO et l'événement
import fr.formation.spring.user.UserAccount;
import fr.formation.spring.user.UserAccountRepository; // Supposons un Repository
import fr.formation.spring.event.UserCreationEvent;

@Service
public class UserAccountService {

    private final ApplicationEventPublisher eventPublisher;
    private final UserAccountRepository userRepository; // Exemple de dépendance

    // Injection de dépendances via le constructeur (bonne pratique)
    @Autowired
    public UserAccountService(
            ApplicationEventPublisher eventPublisher,
            UserAccountRepository userRepository
    ) {
        this.eventPublisher = eventPublisher;
        this.userRepository = userRepository;
    }

    /**
     * Méthode pour enregistrer un nouvel utilisateur.
     * Après sauvegarde, publie un événement UserCreationEvent.
     * @param username Le nom d'utilisateur.
     * @param password Le mot de passe (devrait être hashé !).
     * @param email L'adresse email.
     * @return Le compte utilisateur créé et sauvegardé.
     */
    public UserAccount registerUser(String username, String password, String email) {
        // Logique de création de l'utilisateur
        UserAccount newUser = new UserAccount();
        newUser.setUsername(username);
        // !!! Attention: Hasher le mot de passe en production !!!
        newUser.setPassword(password);
        newUser.setEmail(email);

        // Sauvegarde en base de données (supposée)
        UserAccount savedUser = userRepository.save(newUser);

        // Publication de l'événement APRES la sauvegarde réussie
        // 'this' est la source de l'événement
        UserCreationEvent event = new UserCreationEvent(this, savedUser);
        this.eventPublisher.publishEvent(event);
        System.out.println(&quot;Événement UserCreationEvent publié pour: &quot;
                + savedUser.getUsername());

        return savedUser;
    }
}
</div></section><section class="chapter"><h3 id="couteurs-d-v-nements-eventlistener" data-toc="couteurs-d-v-nements-eventlistener">&Eacute;couteurs d'&Eacute;v&eacute;nements: <code class="code" id="-a0k1zx_52">@EventListener</code></h3><ul class="list _bullet" id="-a0k1zx_49"><li class="list__item" id="-a0k1zx_53"><p id="-a0k1zx_55"><span class="control" id="-a0k1zx_56">D&eacute;finition:</span> Pour r&eacute;agir &agrave; un &eacute;v&eacute;nement, on cr&eacute;e un composant Spring (par exemple, un <code class="code" id="-a0k1zx_57">@Service</code> ou <code class="code" id="-a0k1zx_58">@Component</code>) contenant une m&eacute;thode annot&eacute;e avec <code class="code" id="-a0k1zx_59">@EventListener</code>. Cette m&eacute;thode sera automatiquement invoqu&eacute;e lorsque l'&eacute;v&eacute;nement sp&eacute;cifi&eacute; (ou un de ses sous-types) sera publi&eacute;.</p></li><li class="list__item" id="-a0k1zx_54"><p id="-a0k1zx_60"><span class="control" id="-a0k1zx_61">Signature de la M&eacute;thode:</span> La m&eacute;thode d'&eacute;coute doit accepter en param&egrave;tre le type d'&eacute;v&eacute;nement qu'elle souhaite &eacute;couter.</p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.listener;

import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
// Importe l'événement spécifique
import fr.formation.spring.event.UserCreationEvent;
// Importe un service (ex: email) si nécessaire
import fr.formation.spring.service.EmailService; // Supposons un EmailService

@Component // Déclare ce bean comme un composant Spring
public class UserRegistrationListener {

    private final EmailService emailService; // Service pour envoyer des emails

    // Injection de dépendances
    public UserRegistrationListener(EmailService emailService) {
        this.emailService = emailService;
    }

    /**
     * Méthode qui écoute les événements de type UserCreationEvent.
     * Elle est déclenchée après la publication de l'événement.
     * @param event L'événement UserCreationEvent contenant les données.
     */
    @EventListener
    public void handleUserCreationEvent(UserCreationEvent event) {
        System.out.println(
                &quot;Listener: Événement UserCreationEvent reçu pour l'utilisateur: &quot;
                        + event.getUserAccount().getUsername()
        );

        // Logique à exécuter en réponse à l'événement
        // Par exemple, envoyer un email de bienvenue
        String recipientEmail = event.getUserAccount().getEmail();
        String subject = &quot;Bienvenue chez Nous !&quot;;
        String body = &quot;Bonjour &quot; + event.getUserAccount().getUsername()
                + &quot;, bienvenue sur notre plateforme !&quot;;

        try {
            emailService.sendWelcomeEmail(recipientEmail, subject, body);
            System.out.println(
                    &quot;Listener: Email de bienvenue envoyé à &quot; + recipientEmail
            );
        } catch (Exception e) {
            // Gérer les erreurs d'envoi d'email
            System.err.println(
                    &quot;Listener: Erreur lors de l'envoi de l'email à &quot;
                            + recipientEmail + &quot;: &quot; + e.getMessage()
            );
            // Envisager une logique de retry ou de log d'erreur persistante
        }
    }
}
</div></section><section class="chapter"><h3 id="exercice-1-cr-ation-et-coute-d-un-v-nement-simple" data-toc="exercice-1-cr-ation-et-coute-d-un-v-nement-simple">Exercice 1: Cr&eacute;ation et &Eacute;coute d'un &Eacute;v&eacute;nement Simple</h3><p id="-a0k1zx_62"><span class="control" id="-a0k1zx_68">&Eacute;nonc&eacute;:</span></p><ol class="list _decimal" id="-a0k1zx_63" type="1"><li class="list__item" id="-a0k1zx_69"><p id="-a0k1zx_72">Cr&eacute;ez un &eacute;v&eacute;nement <code class="code" id="-a0k1zx_73">ProductViewedEvent</code> qui se d&eacute;clenche lorsqu'un utilisateur consulte la page de d&eacute;tail d'un produit. Cet &eacute;v&eacute;nement doit contenir l'ID (<code class="code" id="-a0k1zx_74">Long productId</code>) du produit consult&eacute;.</p></li><li class="list__item" id="-a0k1zx_70"><p id="-a0k1zx_75">Cr&eacute;ez un service <code class="code" id="-a0k1zx_76">ProductService</code> avec une m&eacute;thode <code class="code" id="-a0k1zx_77">viewProduct(Long productId)</code> qui simule la r&eacute;cup&eacute;ration d'un produit et publie ensuite l'&eacute;v&eacute;nement <code class="code" id="-a0k1zx_78">ProductViewedEvent</code>.</p></li><li class="list__item" id="-a0k1zx_71"><p id="-a0k1zx_79">Cr&eacute;ez un listener <code class="code" id="-a0k1zx_80">ProductAnalyticsListener</code> qui &eacute;coute <code class="code" id="-a0k1zx_81">ProductViewedEvent</code> et affiche simplement un message dans la console indiquant quel produit a &eacute;t&eacute; vu (par exemple: &quot;Produit ID: [productId] consult&eacute;.&quot;).</p></li></ol><p id="-a0k1zx_64"><span class="control" id="-a0k1zx_82">Fichiers &agrave; cr&eacute;er/modifier:</span></p><ul class="list _bullet" id="-a0k1zx_65"><li class="list__item" id="-a0k1zx_83"><p id="-a0k1zx_86"><code class="code" id="-a0k1zx_87">fr.formation.spring.event.ProductViewedEvent.java</code></p></li><li class="list__item" id="-a0k1zx_84"><p id="-a0k1zx_88"><code class="code" id="-a0k1zx_89">fr.formation.spring.service.ProductService.java</code></p></li><li class="list__item" id="-a0k1zx_85"><p id="-a0k1zx_90"><code class="code" id="-a0k1zx_91">fr.formation.spring.listener.ProductAnalyticsListener.java</code></p></li></ul><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-1" data-toc="correction-exercice-1">Correction Exercice 1</h4></div><div class="collapse__content"><ul class="list _bullet" id="-a0k1zx_92"><li class="list__item" id="-a0k1zx_101"><p id="-a0k1zx_102"><span class="control" id="-a0k1zx_103"><code class="code" id="-a0k1zx_104">fr.formation.spring.event.ProductViewedEvent.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.event;

import org.springframework.context.ApplicationEvent;

/**
 * Événement indiquant qu'un produit spécifique a été consulté.
 */
public class ProductViewedEvent extends ApplicationEvent {

    private final Long productId; // ID du produit consulté

    /**
     * Constructeur.
     * @param source L'objet source de l'événement.
     * @param productId L'ID du produit qui a été vu.
     */
    public ProductViewedEvent(Object source, Long productId) {
        super(source);
        this.productId = productId;
    }

    /**
     * Récupère l'ID du produit associé à cet événement.
     * @return L'ID du produit.
     */
    public Long getProductId() {
        return productId;
    }
}
</div><ul class="list _bullet" id="-a0k1zx_94"><li class="list__item" id="-a0k1zx_105"><p id="-a0k1zx_106"><span class="control" id="-a0k1zx_107"><code class="code" id="-a0k1zx_108">fr.formation.spring.service.ProductService.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.service;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import fr.formation.spring.event.ProductViewedEvent;

@Service
public class ProductService {

    private final ApplicationEventPublisher eventPublisher;

    public ProductService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    /**
     * Simule la consultation d'un produit et publie un événement.
     * @param productId L'ID du produit consulté.
     */
    public void viewProduct(Long productId) {
        // Simule la logique métier (ex: récupérer le produit de la DB)
        System.out.println(
                &quot;Service: Consultation du produit ID: &quot; + productId
        );

        // Publie l'événement après la consultation
        ProductViewedEvent event = new ProductViewedEvent(this, productId);
        this.eventPublisher.publishEvent(event);
        System.out.println(
                &quot;Service: Événement ProductViewedEvent publié pour ID: &quot; + productId
        );
    }
}
</div><ul class="list _bullet" id="-a0k1zx_96"><li class="list__item" id="-a0k1zx_109"><p id="-a0k1zx_110"><span class="control" id="-a0k1zx_111"><code class="code" id="-a0k1zx_112">fr.formation.spring.listener.ProductAnalyticsListener.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.listener;

import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import fr.formation.spring.event.ProductViewedEvent;

@Component
public class ProductAnalyticsListener {

    /**
     * Écoute l'événement ProductViewedEvent.
     * @param event L'événement contenant l'ID du produit.
     */
    @EventListener
    public void handleProductViewed(ProductViewedEvent event) {
        // Simule une action d'analyse ou de log
        System.out.println(
                &quot;Listener Analytics: Produit ID: &quot; + event.getProductId()
                        + &quot; consulté.&quot;
        );
        // Ici pourrait se trouver une logique pour incrémenter un compteur,
        // envoyer des données à un système d'analyse, etc.
    }
}
</div><ul class="list _bullet" id="-a0k1zx_98"><li class="list__item" id="-a0k1zx_113"><p id="-a0k1zx_114"><span class="control" id="-a0k1zx_115">Pour tester (dans une classe de test ou un <code class="code" id="-a0k1zx_116">@PostConstruct</code>) :</span></p></li></ul><div class="code-block" data-lang="java">
// ... Dans une classe annotée @Component ou @SpringBootApplication ...
@Autowired
private ProductService productService;

@PostConstruct
public void testProductView() {
    productService.viewProduct(123L);
}
</div></div></div></section></section></section><section class="chapter"><h2 id="gestion-des-v-nements-et-transactions-transactionaleventlistener" data-toc="gestion-des-v-nements-et-transactions-transactionaleventlistener">Gestion des &Eacute;v&eacute;nements et Transactions: <code class="code" id="-a0k1zx_122">@TransactionalEventListener</code></h2><section class="chapter"><h3 id="le-probl-me" data-toc="le-probl-me">Le Probl&egrave;me</h3><p id="-a0k1zx_123">Consid&eacute;rons notre exemple d'inscription utilisateur (<code class="code" id="-a0k1zx_125">UserCreationEvent</code>). L'&eacute;v&eacute;nement est publi&eacute; <span class="emphasis" id="-a0k1zx_126">&agrave; l'int&eacute;rieur</span> de la m&eacute;thode <code class="code" id="-a0k1zx_127">registerUser</code>. Si cette m&eacute;thode est transactionnelle (<code class="code" id="-a0k1zx_128">@Transactional</code>), la publication peut avoir lieu <span class="emphasis" id="-a0k1zx_129">avant</span> que la transaction ne soit valid&eacute;e (commit).</p><p id="-a0k1zx_124">Si l'envoi de l'email (dans le listener) r&eacute;ussit, mais que la transaction &eacute;choue et effectue un rollback <span class="emphasis" id="-a0k1zx_130">apr&egrave;s</span> la publication, l'utilisateur recevra un email de bienvenue pour un compte qui n'existe finalement pas en base de donn&eacute;es. C'est une incoh&eacute;rence !</p></section><section class="chapter"><h3 id="la-solution-transactionaleventlistener" data-toc="la-solution-transactionaleventlistener">La Solution: <code class="code" id="-a0k1zx_134">@TransactionalEventListener</code></h3><p id="-a0k1zx_132">Spring fournit <code class="code" id="-a0k1zx_135">@TransactionalEventListener</code> comme alternative &agrave; <code class="code" id="-a0k1zx_136">@EventListener</code>. Cette annotation permet de lier l'ex&eacute;cution de l'&eacute;couteur &agrave; une phase sp&eacute;cifique de la transaction de l'&eacute;metteur.</p><ul class="list _bullet" id="-a0k1zx_133"><li class="list__item" id="-a0k1zx_137"><p id="-a0k1zx_138"><span class="control" id="-a0k1zx_140">Phases Principales:</span></p><ul class="list _bullet" id="-a0k1zx_139"><li class="list__item" id="-a0k1zx_141"><p id="-a0k1zx_145"><code class="code" id="-a0k1zx_146">AFTER_COMMIT</code> (par d&eacute;faut): L'&eacute;couteur n'est ex&eacute;cut&eacute; que si la transaction de l'&eacute;metteur est valid&eacute;e avec succ&egrave;s. C'est le cas d'usage le plus courant pour garantir la coh&eacute;rence.</p></li><li class="list__item" id="-a0k1zx_142"><p id="-a0k1zx_147"><code class="code" id="-a0k1zx_148">AFTER_ROLLBACK</code>: L'&eacute;couteur est ex&eacute;cut&eacute; si la transaction &eacute;choue et est annul&eacute;e. Utile pour des actions de nettoyage ou de notification d'&eacute;chec.</p></li><li class="list__item" id="-a0k1zx_143"><p id="-a0k1zx_149"><code class="code" id="-a0k1zx_150">AFTER_COMPLETION</code>: L'&eacute;couteur est ex&eacute;cut&eacute; apr&egrave;s la fin de la transaction, qu'elle soit valid&eacute;e ou annul&eacute;e (commit ou rollback).</p></li><li class="list__item" id="-a0k1zx_144"><p id="-a0k1zx_151"><code class="code" id="-a0k1zx_152">BEFORE_COMMIT</code>: L'&eacute;couteur est ex&eacute;cut&eacute; juste avant le commit de la transaction. Usage moins fr&eacute;quent, potentiellement pour des validations finales.</p></li></ul></li></ul></section><section class="chapter"><h3 id="exemple-d-utilisation" data-toc="exemple-d-utilisation">Exemple d'Utilisation</h3><p id="-a0k1zx_153">Modifions notre <code class="code" id="-a0k1zx_159">UserRegistrationListener</code> pour qu'il n'envoie l'email qu'apr&egrave;s le commit de la transaction.</p><div class="code-block" data-lang="java">
package fr.formation.spring.listener;

// ... autres imports ...

import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase; // Important
import org.springframework.transaction.event.TransactionalEventListener; // Important
import fr.formation.spring.event.UserCreationEvent;
import fr.formation.spring.service.EmailService;

@Component
public class UserRegistrationTransactionalListener { // Renommé pour clarté

    private final EmailService emailService;

    public UserRegistrationTransactionalListener(EmailService emailService) {
        this.emailService = emailService;
    }

    /**
     * Écoute UserCreationEvent, mais seulement APRES le commit
     * de la transaction dans laquelle l'événement a été publié.
     * @param event L'événement contenant les données utilisateur.
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    // Si phase non spécifiée, AFTER_COMMIT est utilisé par défaut
    // @TransactionalEventListener // Équivalent
    public void handleUserCreationCommit(UserCreationEvent event) {
        System.out.println(
                &quot;[Transactional Listener AFTER_COMMIT]: &quot; +
                        &quot;Transaction validée pour user &quot; + event.getUserAccount().getUsername()
                        + &quot;. Envoi de l'email...&quot;
        );

        String recipientEmail = event.getUserAccount().getEmail();
        // ... logique d'envoi d'email ...
        try {
            emailService.sendWelcomeEmail(recipientEmail, &quot;Bienvenue&quot;, &quot;...&quot;);
            System.out.println(
                    &quot;[Transactional Listener AFTER_COMMIT]: Email envoyé à &quot;
                            + recipientEmail
            );
        } catch (Exception e) {
            System.err.println(
                    &quot;[Transactional Listener AFTER_COMMIT]: Erreur email: &quot;
                            + e.getMessage()
            );
            // Que faire si l'email échoue APRES le commit ?
            // Logguer l'erreur, mettre dans une file d'attente de retry, etc.
        }
    }

    /**
     * Exemple d'écouteur pour le cas du rollback.
     * @param event L'événement.
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
    public void handleUserCreationRollback(UserCreationEvent event) {
        System.out.println(
                &quot;[Transactional Listener AFTER_ROLLBACK]: &quot; +
                        &quot;Transaction annulée pour user &quot; + event.getUserAccount().getUsername()
                        + &quot;. Aucune action requise ou log spécifique.&quot;
        );
        // Utile pour notifier un admin, ou nettoyer des ressources externes
        // qui auraient pu être créées avant le rollback (rare si bien conçu).
    }
}
</div><p id="-a0k1zx_155"><span class="control" id="-a0k1zx_160">Important:</span> Pour que <code class="code" id="-a0k1zx_161">@TransactionalEventListener</code> fonctionne, la m&eacute;thode qui publie l'&eacute;v&eacute;nement (ici <code class="code" id="-a0k1zx_162">registerUser</code>) doit s'ex&eacute;cuter dans le contexte d'une transaction Spring (par exemple, &ecirc;tre annot&eacute;e avec <code class="code" id="-a0k1zx_163">@Transactional</code> ou appel&eacute;e par une m&eacute;thode qui l'est).</p><div class="code-block" data-lang="java">
package fr.formation.spring.service;

// ... autres imports ...

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // Important

@Service
public class UserAccountService {
    // ... constructeur et autres dépendances ...

    @Transactional // Assure que la méthode s'exécute dans une transaction
    public UserAccount registerUser(String username, String password, String email) {
        // ... logique de création et sauvegarde ...
        UserAccount savedUser = userRepository.save(newUser);

        // L'événement est publié DANS la transaction
        UserCreationEvent event = new UserCreationEvent(this, savedUser);
        this.eventPublisher.publishEvent(event);
        System.out.println(
                &quot;Événement UserCreationEvent publié (dans transaction) pour: &quot;
                        + savedUser.getUsername()
        );

        // // Décommenter pour simuler un rollback:
        // if (true) {
        //     throw new RuntimeException(&quot;Simulation d'échec après publication !&quot;);
        // }

        return savedUser; // Commit implicite à la fin si pas d'exception
    }
}
</div><p id="-a0k1zx_157"><span class="control" id="-a0k1zx_164">Cas d'Utilisation Typique:</span> Envoi de notifications (email, SMS), mise &agrave; jour de syst&egrave;mes externes, invalidation de cache, d&eacute;clenchement de t&acirc;ches asynchrones, <span class="emphasis" id="-a0k1zx_165">uniquement</span> si l'op&eacute;ration principale en base de donn&eacute;es a r&eacute;ussi.</p></section><section class="chapter"><h3 id="exercice-2-utilisation-de-transactionaleventlistener" data-toc="exercice-2-utilisation-de-transactionaleventlistener">Exercice 2: Utilisation de <code class="code" id="-a0k1zx_173">@TransactionalEventListener</code></h3><p id="-a0k1zx_167"><span class="control" id="-a0k1zx_174">&Eacute;nonc&eacute;:</span> On suppose qu'ajouter un produit au panier (<code class="code" id="-a0k1zx_175">CartItem</code>) implique une sauvegarde en base de donn&eacute;es et que cette op&eacute;ration est transactionnelle.</p><ol class="list _decimal" id="-a0k1zx_168" type="1"><li class="list__item" id="-a0k1zx_176"><p id="-a0k1zx_180">Cr&eacute;ez un &eacute;v&eacute;nement <code class="code" id="-a0k1zx_181">ItemAddedToCartEvent</code> contenant l'ID de l'utilisateur (<code class="code" id="-a0k1zx_182">Long userId</code>) et l'ID du produit (<code class="code" id="-a0k1zx_183">Long productId</code>).</p></li><li class="list__item" id="-a0k1zx_177"><p id="-a0k1zx_184">Modifiez (ou cr&eacute;ez) un service <code class="code" id="-a0k1zx_185">ShoppingCartService</code> avec une m&eacute;thode <code class="code" id="-a0k1zx_186">@Transactional addItemToCart(Long userId, Long productId)</code> qui simule l'ajout au panier (par exemple, sauvegarde une entit&eacute; <code class="code" id="-a0k1zx_187">CartItem</code>) et publie l'&eacute;v&eacute;nement <code class="code" id="-a0k1zx_188">ItemAddedToCartEvent</code>.</p></li><li class="list__item" id="-a0k1zx_178"><p id="-a0k1zx_189">Cr&eacute;ez un listener <code class="code" id="-a0k1zx_190">CartUpdateNotifierListener</code> qui utilise <code class="code" id="-a0k1zx_191">@TransactionalEventListener</code> pour &eacute;couter <code class="code" id="-a0k1zx_192">ItemAddedToCartEvent</code> <span class="emphasis" id="-a0k1zx_193">uniquement apr&egrave;s le commit</span> de la transaction. Ce listener affichera un message dans la console indiquant que le panier de l'utilisateur a &eacute;t&eacute; mis &agrave; jour.</p></li><li class="list__item" id="-a0k1zx_179"><p id="-a0k1zx_194">(Optionnel) Ajoutez un second listener dans <code class="code" id="-a0k1zx_195">CartUpdateNotifierListener</code> qui &eacute;coute le m&ecirc;me &eacute;v&eacute;nement mais en phase <code class="code" id="-a0k1zx_196">AFTER_ROLLBACK</code> et affiche un message diff&eacute;rent.</p></li></ol><p id="-a0k1zx_169"><span class="control" id="-a0k1zx_197">Fichiers &agrave; cr&eacute;er/modifier:</span></p><ul class="list _bullet" id="-a0k1zx_170"><li class="list__item" id="-a0k1zx_198"><p id="-a0k1zx_203"><code class="code" id="-a0k1zx_204">fr.formation.spring.event.ItemAddedToCartEvent.java</code></p></li><li class="list__item" id="-a0k1zx_199"><p id="-a0k1zx_205"><code class="code" id="-a0k1zx_206">fr.formation.spring.service.ShoppingCartService.java</code> (avec une d&eacute;pendance simul&eacute;e vers un <code class="code" id="-a0k1zx_207">CartItemRepository</code>)</p></li><li class="list__item" id="-a0k1zx_200"><p id="-a0k1zx_208"><code class="code" id="-a0k1zx_209">fr.formation.spring.listener.CartUpdateNotifierListener.java</code></p></li><li class="list__item" id="-a0k1zx_201"><p id="-a0k1zx_210">(Optionnel) <code class="code" id="-a0k1zx_211">fr.formation.spring.model.CartItem.java</code> (simple classe POJO ou Entit&eacute; JPA)</p></li><li class="list__item" id="-a0k1zx_202"><p id="-a0k1zx_212">(Optionnel) <code class="code" id="-a0k1zx_213">fr.formation.spring.repository.CartItemRepository.java</code> (Interface simple)</p></li></ul><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-2" data-toc="correction-exercice-2">Correction Exercice 2</h4></div><div class="collapse__content"><ul class="list _bullet" id="-a0k1zx_214"><li class="list__item" id="-a0k1zx_227"><p id="-a0k1zx_228"><span class="control" id="-a0k1zx_229"><code class="code" id="-a0k1zx_230">fr.formation.spring.event.ItemAddedToCartEvent.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.event;

import org.springframework.context.ApplicationEvent;

/**
 * Événement indiquant qu'un article a été ajouté au panier d'un utilisateur.
 */
public class ItemAddedToCartEvent extends ApplicationEvent {

    private final Long userId;
    private final Long productId;

    public ItemAddedToCartEvent(Object source, Long userId, Long productId) {
        super(source);
        this.userId = userId;
        this.productId = productId;
    }

    public Long getUserId() {
        return userId;
    }

    public Long getProductId() {
        return productId;
    }
}
</div><ul class="list _bullet" id="-a0k1zx_216"><li class="list__item" id="-a0k1zx_231"><p id="-a0k1zx_232"><span class="control" id="-a0k1zx_233">(Optionnel) <code class="code" id="-a0k1zx_234">fr.formation.spring.model.CartItem.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.model;

// Simulation simple, pourrait être une @Entity JPA
public class CartItem {
    private Long id;
    private Long userId;
    private Long productId;
    private int quantity;
    // Getters, Setters...
}
</div><ul class="list _bullet" id="-a0k1zx_218"><li class="list__item" id="-a0k1zx_235"><p id="-a0k1zx_236"><span class="control" id="-a0k1zx_237">(Optionnel) <code class="code" id="-a0k1zx_238">fr.formation.spring.repository.CartItemRepository.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.repository;

import org.springframework.stereotype.Repository;
import fr.formation.spring.model.CartItem;

// Simulation d'un repository
@Repository
public interface CartItemRepository {
    CartItem save(CartItem item); // Méthode simulée
}

// Implémentation factice pour l'exemple si pas de JPA/JDBC configuré
@Repository
class MockCartItemRepositoryImpl implements CartItemRepository {
    @Override
    public CartItem save(CartItem item) {
        System.out.println(&quot;Simulating save of CartItem for user &quot;
                + item.getUserId() + &quot;, product &quot; + item.getProductId());
        // Simule l'attribution d'un ID
        item.setId((long) (Math.random() * 1000));
        return item;
    }
}
</div><ul class="list _bullet" id="-a0k1zx_220"><li class="list__item" id="-a0k1zx_239"><p id="-a0k1zx_240"><span class="control" id="-a0k1zx_241"><code class="code" id="-a0k1zx_242">fr.formation.spring.service.ShoppingCartService.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.service;

import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import fr.formation.spring.event.ItemAddedToCartEvent;
import fr.formation.spring.model.CartItem; // Si défini
import fr.formation.spring.repository.CartItemRepository; // Si défini

@Service
public class ShoppingCartService {

    private final ApplicationEventPublisher eventPublisher;
    private final CartItemRepository cartItemRepository; // Injection repo

    public ShoppingCartService(ApplicationEventPublisher eventPublisher,
                               CartItemRepository cartItemRepository) {
        this.eventPublisher = eventPublisher;
        this.cartItemRepository = cartItemRepository;
    }

    /**
     * Ajoute un article au panier (transactionnel).
     * Publie un événement ItemAddedToCartEvent si réussi.
     * @param userId ID de l'utilisateur.
     * @param productId ID du produit.
     * @return Le CartItem sauvegardé (ou simulé).
     */
    @Transactional // Important pour @TransactionalEventListener
    public CartItem addItemToCart(Long userId, Long productId) {
        System.out.println(&quot;Service: Ajout du produit &quot; + productId
                + &quot; au panier de l'utilisateur &quot; + userId);

        // Simule la création/mise à jour de l'item dans le panier
        CartItem item = new CartItem(); // Créer un objet CartItem
        item.setUserId(userId);
        item.setProductId(productId);
        item.setQuantity(1); // ou incrémenter si existant

        CartItem savedItem = cartItemRepository.save(item); // Sauvegarde DB

        // Publie l'événement DANS la transaction
        ItemAddedToCartEvent event =
                new ItemAddedToCartEvent(this, userId, productId);
        this.eventPublisher.publishEvent(event);
        System.out.println(&quot;Service: Événement ItemAddedToCartEvent publié.&quot;);

        // // Décommenter pour tester le rollback:
        // if (productId == 999L) { // Condition pour simuler un échec
        //     throw new RuntimeException(&quot;Échec simulé de l'ajout au panier !&quot;);
        // }

        return savedItem; // Commit implicite ici si pas d'exception
    }
}
</div><ul class="list _bullet" id="-a0k1zx_222"><li class="list__item" id="-a0k1zx_243"><p id="-a0k1zx_244"><span class="control" id="-a0k1zx_245"><code class="code" id="-a0k1zx_246">fr.formation.spring.listener.CartUpdateNotifierListener.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.listener;

import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;
import fr.formation.spring.event.ItemAddedToCartEvent;

@Component
public class CartUpdateNotifierListener {

    /**
     * Notifie après commit réussi de l'ajout au panier.
     * @param event L'événement contenant les détails.
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleCartUpdateCommit(ItemAddedToCartEvent event) {
        System.out.println(
                &quot;[Notifier Listener AFTER_COMMIT]: Le panier de l'utilisateur &quot;
                        + event.getUserId() + &quot; a été mis à jour avec le produit &quot;
                        + event.getProductId() + &quot;. Transaction validée.&quot;
        );
        // Ici, on pourrait rafraîchir une partie de l'UI via WebSockets,
        // ou notifier un autre système.
    }

    /**
     * (Optionnel) Gère le cas où la transaction d'ajout a échoué.
     * @param event L'événement.
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
    public void handleCartUpdateRollback(ItemAddedToCartEvent event) {
        System.out.println(
                &quot;[Notifier Listener AFTER_ROLLBACK]: Échec de l'ajout du produit &quot;
                        + event.getProductId() + &quot; pour l'utilisateur &quot;
                        + event.getUserId() + &quot;. Transaction annulée.&quot;
        );
        // Logguer l'échec, notifier l'admin si nécessaire.
    }
}
</div><ul class="list _bullet" id="-a0k1zx_224"><li class="list__item" id="-a0k1zx_247"><p id="-a0k1zx_248"><span class="control" id="-a0k1zx_249">Pour tester (simuler un contr&ocirc;leur web ou autre service):</span></p></li></ul><div class="code-block" data-lang="java">
// ... Dans une classe de test ou composant ...
@Autowired
private ShoppingCartService cartService;

public void simulateAddToCart() {
    try {
        cartService.addItemToCart(1L, 101L); // Cas succès
    } catch (Exception e) {
        System.err.println(&quot;Erreur lors de l'ajout : &quot; + e.getMessage());
    }
    try {
        // Pour tester le rollback, décommenter le throw dans le service
        // et appeler avec productId = 999L
        // cartService.addItemToCart(2L, 999L);
    } catch (Exception e) {
        System.err.println(&quot;Erreur attendue lors de l'ajout : &quot; + e.getMessage());
    }
}
</div></div></div></section></section></section><section class="chapter"><h2 id="couteurs-d-entit-s-jpa-entitylisteners" data-toc="couteurs-d-entit-s-jpa-entitylisteners">&Eacute;couteurs d'Entit&eacute;s JPA: <code class="code" id="-a0k1zx_256">@EntityListeners</code></h2><section class="chapter"><h3 id="contexte" data-toc="contexte">Contexte</h3><p id="-a0k1zx_257">Parfois, on souhaite r&eacute;agir sp&eacute;cifiquement aux &eacute;v&eacute;nements du cycle de vie d'une entit&eacute; JPA (cr&eacute;ation, mise &agrave; jour, suppression), par exemple pour l'audit (qui a cr&eacute;&eacute;/modifi&eacute; quoi et quand), ou pour mettre &agrave; jour des champs d&eacute;riv&eacute;s. JPA fournit des annotations de callback de cycle de vie (<code class="code" id="-a0k1zx_259">@PrePersist</code>, <code class="code" id="-a0k1zx_260">@PostPersist</code>, <code class="code" id="-a0k1zx_261">@PreUpdate</code>, <code class="code" id="-a0k1zx_262">@PostUpdate</code>, <code class="code" id="-a0k1zx_263">@PreRemove</code>, <code class="code" id="-a0k1zx_264">@PostRemove</code>, <code class="code" id="-a0k1zx_265">@PostLoad</code>).</p><p id="-a0k1zx_258">On peut placer ces annotations directement dans l'entit&eacute; ou, pour une meilleure s&eacute;paration des pr&eacute;occupations (surtout si la logique est complexe ou r&eacute;utilis&eacute;e), dans une classe externe appel&eacute;e <span class="emphasis" id="-a0k1zx_266">Entity Listener</span>.</p></section><section class="chapter"><h3 id="entitylisteners" data-toc="entitylisteners"><code class="code" id="-a0k1zx_269">@EntityListeners</code></h3><p id="-a0k1zx_268">L'annotation <code class="code" id="-a0k1zx_270">@EntityListeners</code> s'applique sur une classe d'entit&eacute; JPA et sp&eacute;cifie une ou plusieurs classes d'&eacute;couteurs qui contiennent les m&eacute;thodes de callback.</p></section><section class="chapter"><h3 id="cr-ation-d-un-entity-listener" data-toc="cr-ation-d-un-entity-listener">Cr&eacute;ation d'un Entity Listener</h3><p id="-a0k1zx_271">Un Entity Listener est une simple classe (pas n&eacute;cessairement un bean Spring par d&eacute;faut, mais peut l'&ecirc;tre) contenant des m&eacute;thodes annot&eacute;es avec les annotations de callback JPA. Ces m&eacute;thodes re&ccedil;oivent l'entit&eacute; concern&eacute;e en param&egrave;tre.</p><div class="code-block" data-lang="java">
package fr.formation.spring.jpa.listener;

import java.time.LocalDateTime;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
// Importe une interface/classe de base pour les entités auditables
import fr.formation.spring.jpa.model.Auditable;

/**
 * Écouteur d'entité JPA pour gérer automatiquement les champs d'audit
 * (date de création et de dernière modification).
 */
public class AuditListener {

    /**
     * Méthode exécutée AVANT la persistance (création) d'une entité.
     * Initialise les dates de création et de mise à jour.
     * @param entity L'objet entité sur le point d'être persisté.
     *               Doit implémenter l'interface Auditable.
     */
    @PrePersist
    public void setCreationTimestamp(Object entity) {
        if (entity instanceof Auditable) {
            Auditable auditableEntity = (Auditable) entity;
            LocalDateTime now = LocalDateTime.now();
            if (auditableEntity.getCreatedAt() == null) {
                auditableEntity.setCreatedAt(now);
            }
            // La date de màj est aussi mise à jour lors de la création
            auditableEntity.setUpdatedAt(now);
            System.out.println(&quot;AuditListener @PrePersist: Set timestamps for &quot;
                    + entity.getClass().getSimpleName());
        }
    }

    /**
     * Méthode exécutée AVANT la mise à jour d'une entité existante.
     * Met à jour la date de dernière modification.
     * @param entity L'objet entité sur le point d'être mis à jour.
     *               Doit implémenter l'interface Auditable.
     */
    @PreUpdate
    public void setUpdateTimestamp(Object entity) {
        if (entity instanceof Auditable) {
            Auditable auditableEntity = (Auditable) entity;
            auditableEntity.setUpdatedAt(LocalDateTime.now());
            System.out.println(&quot;AuditListener @PreUpdate: Set update timestamp for &quot;
                    + entity.getClass().getSimpleName());
        }
    }
}

// Interface commune pour les entités nécessitant un audit de date
package fr.formation.spring.jpa.model;

import java.time.LocalDateTime;

public interface Auditable {
    LocalDateTime getCreatedAt();

    void setCreatedAt(LocalDateTime createdAt);

    LocalDateTime getUpdatedAt();

    void setUpdatedAt(LocalDateTime updatedAt);
}
</div></section><section class="chapter"><h3 id="application-une-entit" data-toc="application-une-entit">Application &agrave; une Entit&eacute;</h3><p id="-a0k1zx_273">Il suffit ensuite d'annoter l'entit&eacute; JPA avec <code class="code" id="-a0k1zx_279">@EntityListeners</code>.</p><div class="code-block" data-lang="java">
package fr.formation.spring.jpa.model;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityListeners; // Important
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
// Importe l'interface et le listener
import fr.formation.spring.jpa.listener.AuditListener;

@Entity
@EntityListeners(AuditListener.class) // Applique le listener à cette entité
public class Order implements Auditable { // Implémente l'interface Auditable

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    // ... autres champs de la commande ...

    @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)
    private LocalDateTime createdAt; // Champ pour la date de création

    @Column(name = &quot;updated_at&quot;, nullable = false)
    private LocalDateTime updatedAt; // Champ pour la date de mise à jour

    // Implémentation des méthodes de l'interface Auditable
    @Override
    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    @Override
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    @Override
    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    @Override
    public void setUpdatedAt(LocalDateTime updatedAt) {
        this.updatedAt = updatedAt;
    }

    // Getters, Setters pour les autres champs (id, orderNumber...)
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public void setOrderNumber(String orderNumber) {
        this.orderNumber = orderNumber;
    }
}
</div><p id="-a0k1zx_275">Maintenant, chaque fois qu'une entit&eacute; <code class="code" id="-a0k1zx_280">Order</code> sera cr&eacute;&eacute;e (<code class="code" id="-a0k1zx_281">persist</code>) ou mise &agrave; jour (<code class="code" id="-a0k1zx_282">merge</code>), les m&eacute;thodes <code class="code" id="-a0k1zx_283">@PrePersist</code> et <code class="code" id="-a0k1zx_284">@PreUpdate</code> de <code class="code" id="-a0k1zx_285">AuditListener</code> seront automatiquement appel&eacute;es par JPA pour remplir les champs <code class="code" id="-a0k1zx_286">createdAt</code> et <code class="code" id="-a0k1zx_287">updatedAt</code>.</p><p id="-a0k1zx_276"><span class="control" id="-a0k1zx_288">Lien avec les &Eacute;v&eacute;nements Spring:</span> Bien que les <code class="code" id="-a0k1zx_289">EntityListeners</code> soient un m&eacute;canisme JPA, ils peuvent &ecirc;tre utilis&eacute;s pour <span class="emphasis" id="-a0k1zx_290">publier</span> des <code class="code" id="-a0k1zx_291">ApplicationEvent</code> Spring si n&eacute;cessaire. Par exemple, un <code class="code" id="-a0k1zx_292">@PostPersist</code> pourrait utiliser un <code class="code" id="-a0k1zx_293">ApplicationEventPublisher</code> (inject&eacute; si l'EntityListener est g&eacute;r&eacute; par Spring, voir ci-dessous) pour signaler la cr&eacute;ation d'une entit&eacute; &agrave; d'autres parties de l'application.</p><p id="-a0k1zx_277"><span class="control" id="-a0k1zx_294">Injection de D&eacute;pendances dans les Entity Listeners:</span> Par d&eacute;faut, les Entity Listeners sont instanci&eacute;s directement par JPA et ne sont pas des beans Spring. Si un Entity Listener a besoin de d&eacute;pendances Spring (comme <code class="code" id="-a0k1zx_295">ApplicationEventPublisher</code>), il faut configurer JPA pour qu'il utilise le contexte Spring pour obtenir les instances de listeners. Cela se fait souvent via la configuration de <code class="code" id="-a0k1zx_296">LocalContainerEntityManagerFactoryBean</code> ou via des propri&eacute;t&eacute;s sp&eacute;cifiques au fournisseur JPA (Hibernate, EclipseLink). Une alternative plus simple est parfois d'utiliser un bean Spring statique accessible depuis le listener. Spring Data JPA fournit &eacute;galement des facilit&eacute;s pour l'audit (<code class="code" id="-a0k1zx_297">@EnableJpaAuditing</code>, <code class="code" id="-a0k1zx_298">@CreatedDate</code>, <code class="code" id="-a0k1zx_299">@LastModifiedDate</code>) qui sont souvent pr&eacute;f&eacute;rables pour ce cas d'usage pr&eacute;cis.</p></section><section class="chapter"><h3 id="exercice-3-mise-en-place-d-un-audit-simple-avec-entitylisteners" data-toc="exercice-3-mise-en-place-d-un-audit-simple-avec-entitylisteners">Exercice 3: Mise en place d'un Audit Simple avec <code class="code" id="-a0k1zx_307">@EntityListeners</code></h3><p id="-a0k1zx_301"><span class="control" id="-a0k1zx_308">&Eacute;nonc&eacute;:</span></p><ol class="list _decimal" id="-a0k1zx_302" type="1"><li class="list__item" id="-a0k1zx_309"><p id="-a0k1zx_315">Cr&eacute;ez une entit&eacute; JPA simple <code class="code" id="-a0k1zx_316">BlogPost</code> avec au moins un champ <code class="code" id="-a0k1zx_317">title</code> (String) et un champ <code class="code" id="-a0k1zx_318">content</code> (String).</p></li><li class="list__item" id="-a0k1zx_310"><p id="-a0k1zx_319">Ajoutez les champs <code class="code" id="-a0k1zx_320">creationDate</code> (LocalDateTime) et <code class="code" id="-a0k1zx_321">lastUpdateDate</code> (LocalDateTime) &agrave; l'entit&eacute; <code class="code" id="-a0k1zx_322">BlogPost</code>.</p></li><li class="list__item" id="-a0k1zx_311"><p id="-a0k1zx_323">Cr&eacute;ez une interface <code class="code" id="-a0k1zx_324">Timestamped</code> avec les m&eacute;thodes <code class="code" id="-a0k1zx_325">getCreationDate()</code>, <code class="code" id="-a0k1zx_326">setCreationDate()</code>, <code class="code" id="-a0k1zx_327">getLastUpdateDate()</code>, <code class="code" id="-a0k1zx_328">setLastUpdateDate()</code>. Faites impl&eacute;menter cette interface par <code class="code" id="-a0k1zx_329">BlogPost</code>.</p></li><li class="list__item" id="-a0k1zx_312"><p id="-a0k1zx_330">Cr&eacute;ez un <code class="code" id="-a0k1zx_331">EntityListener</code> nomm&eacute; <code class="code" id="-a0k1zx_332">TimestampListener</code> avec des m&eacute;thodes <code class="code" id="-a0k1zx_333">@PrePersist</code> et <code class="code" id="-a0k1zx_334">@PreUpdate</code> pour initialiser/mettre &agrave; jour ces dates, similaire &agrave; l'exemple <code class="code" id="-a0k1zx_335">AuditListener</code>.</p></li><li class="list__item" id="-a0k1zx_313"><p id="-a0k1zx_336">Annotez l'entit&eacute; <code class="code" id="-a0k1zx_337">BlogPost</code> avec <code class="code" id="-a0k1zx_338">@EntityListeners(TimestampListener.class)</code>.</p></li><li class="list__item" id="-a0k1zx_314"><p id="-a0k1zx_339">(Simulation) Dans un service ou un test, cr&eacute;ez une instance de <code class="code" id="-a0k1zx_340">BlogPost</code>, sauvegardez-la (simulez avec un <code class="code" id="-a0k1zx_341">EntityManager</code> ou un <code class="code" id="-a0k1zx_342">Repository</code>), modifiez-la, puis sauvegardez &agrave; nouveau. V&eacute;rifiez (par affichage console dans le listener ou en r&eacute;cup&eacute;rant l'entit&eacute;) que les dates ont &eacute;t&eacute; correctement d&eacute;finies.</p></li></ol><p id="-a0k1zx_303"><span class="control" id="-a0k1zx_343">Fichiers &agrave; cr&eacute;er/modifier:</span></p><ul class="list _bullet" id="-a0k1zx_304"><li class="list__item" id="-a0k1zx_344"><p id="-a0k1zx_348"><code class="code" id="-a0k1zx_349">fr.formation.spring.jpa.model.BlogPost.java</code></p></li><li class="list__item" id="-a0k1zx_345"><p id="-a0k1zx_350"><code class="code" id="-a0k1zx_351">fr.formation.spring.jpa.model.Timestamped.java</code> (Interface)</p></li><li class="list__item" id="-a0k1zx_346"><p id="-a0k1zx_352"><code class="code" id="-a0k1zx_353">fr.formation.spring.jpa.listener.TimestampListener.java</code></p></li><li class="list__item" id="-a0k1zx_347"><p id="-a0k1zx_354">(Optionnel) Un service ou une classe de test pour simuler la persistance.</p></li></ul><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-3" data-toc="correction-exercice-3">Correction Exercice 3</h4></div><div class="collapse__content"><ul class="list _bullet" id="-a0k1zx_355"><li class="list__item" id="-a0k1zx_364"><p id="-a0k1zx_365"><span class="control" id="-a0k1zx_366"><code class="code" id="-a0k1zx_367">fr.formation.spring.jpa.model.Timestamped.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.jpa.model;

import java.time.LocalDateTime;

/**
 * Interface pour les entités qui doivent avoir des timestamps de création/màj.
 */
public interface Timestamped {
    LocalDateTime getCreationDate();

    void setCreationDate(LocalDateTime creationDate);

    LocalDateTime getLastUpdateDate();

    void setLastUpdateDate(LocalDateTime lastUpdateDate);
}
</div><ul class="list _bullet" id="-a0k1zx_357"><li class="list__item" id="-a0k1zx_368"><p id="-a0k1zx_369"><span class="control" id="-a0k1zx_370"><code class="code" id="-a0k1zx_371">fr.formation.spring.jpa.model.BlogPost.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.jpa.model;

import java.time.LocalDateTime;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityListeners;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Lob; // Pour les champs texte longs

import fr.formation.spring.jpa.listener.TimestampListener; // Import listener

@Entity
@EntityListeners(TimestampListener.class) // Applique le listener
public class BlogPost implements Timestamped { // Implémente l'interface

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Lob // Indique un champ potentiellement grand (CLOB/TEXT)
    private String content;

    @Column(name = &quot;creation_date&quot;, nullable = false, updatable = false)
    private LocalDateTime creationDate;

    @Column(name = &quot;last_update_date&quot;, nullable = false)
    private LocalDateTime lastUpdateDate;

    // Implémentation interface Timestamped
    @Override
    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    @Override
    public void setCreationDate(LocalDateTime date) {
        this.creationDate = date;
    }

    @Override
    public LocalDateTime getLastUpdateDate() {
        return lastUpdateDate;
    }

    @Override
    public void setLastUpdateDate(LocalDateTime date) {
        this.lastUpdateDate = date;
    }

    // Getters &amp; Setters pour id, title, content
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return &quot;BlogPost [id=&quot; + id + &quot;, title=&quot; + title
                + &quot;, creationDate=&quot; + creationDate
                + &quot;, lastUpdateDate=&quot; + lastUpdateDate + &quot;]&quot;;
    }
}
</div><ul class="list _bullet" id="-a0k1zx_359"><li class="list__item" id="-a0k1zx_372"><p id="-a0k1zx_373"><span class="control" id="-a0k1zx_374"><code class="code" id="-a0k1zx_375">fr.formation.spring.jpa.listener.TimestampListener.java</code></span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.jpa.listener;

import java.time.LocalDateTime;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;

import fr.formation.spring.jpa.model.Timestamped; // Import interface

/**
 * Entity Listener pour gérer les timestamps de création et de mise à jour.
 */
public class TimestampListener {

    @PrePersist
    public void onPrePersist(Object entity) {
        if (entity instanceof Timestamped) {
            Timestamped timestampedEntity = (Timestamped) entity;
            LocalDateTime now = LocalDateTime.now();
            if (timestampedEntity.getCreationDate() == null) {
                timestampedEntity.setCreationDate(now);
            }
            timestampedEntity.setLastUpdateDate(now); // Aussi lors création
            System.out.println(
                    &quot;TimestampListener @PrePersist: Set timestamps on &quot;
                            + entity.getClass().getSimpleName()
            );
        }
    }

    @PreUpdate
    public void onPreUpdate(Object entity) {
        if (entity instanceof Timestamped) {
            Timestamped timestampedEntity = (Timestamped) entity;
            timestampedEntity.setLastUpdateDate(LocalDateTime.now());
            System.out.println(
                    &quot;TimestampListener @PreUpdate: Set lastUpdateDate on &quot;
                            + entity.getClass().getSimpleName()
            );
        }
    }
}
</div><ul class="list _bullet" id="-a0k1zx_361"><li class="list__item" id="-a0k1zx_376"><p id="-a0k1zx_377"><span class="control" id="-a0k1zx_378">Simulation de persistance (Exemple avec Spring Data JPA Repository):</span></p></li></ul><div class="code-block" data-lang="java">
package fr.formation.spring.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import fr.formation.spring.jpa.model.BlogPost;

// Suppose que Spring Data JPA est configuré
public interface BlogPostRepository extends JpaRepository&lt;BlogPost, Long&gt; {
}

// --- Dans un service ou une classe de test ---
package fr.formation.spring.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import fr.formation.spring.jpa.model.BlogPost;
import fr.formation.spring.repository.BlogPostRepository;

@Service
public class BlogService {

    @Autowired
    private BlogPostRepository blogPostRepository;

    @Transactional // Important pour la gestion par JPA/Hibernate
    public void demonstrateTimestamps() {
        System.out.println(&quot;--- Création du Post ---&quot;);
        BlogPost post = new BlogPost();
        post.setTitle(&quot;Mon Premier Article&quot;);
        post.setContent(&quot;Contenu de l'article...&quot;);

        // Sauvegarde initiale (déclenche @PrePersist)
        BlogPost savedPost = blogPostRepository.save(post);
        System.out.println(&quot;Post sauvegardé: &quot; + savedPost);

        // Pause pour voir une différence dans les dates
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }

        System.out.println(&quot;\n--- Mise à jour du Post ---&quot;);
        // Récupération (optionnel, save fait aussi un merge si ID existe)
        BlogPost postToUpdate = blogPostRepository.findById(savedPost.getId())
                .orElseThrow();
        postToUpdate.setContent(&quot;Contenu mis à jour !&quot;);

        // Sauvegarde (déclenche @PreUpdate)
        BlogPost updatedPost = blogPostRepository.save(postToUpdate);
        System.out.println(&quot;Post mis à jour: &quot; + updatedPost);
    }
}

// --- Pour exécuter (ex: dans la classe principale ou un test) ---
// @Autowired BlogService blogService;
// blogService.demonstrateTimestamps();
</div><p id="-a0k1zx_363">L'ex&eacute;cution de <code class="code" id="-a0k1zx_379">demonstrateTimestamps</code> devrait montrer dans la console les messages du <code class="code" id="-a0k1zx_380">TimestampListener</code> et les objets <code class="code" id="-a0k1zx_381">BlogPost</code> avec les dates <code class="code" id="-a0k1zx_382">creationDate</code> et <code class="code" id="-a0k1zx_383">lastUpdateDate</code> correctement renseign&eacute;es et mises &agrave; jour.</p></div></div></section></section></section><section class="chapter"><h2 id="cas-d-utilisation-typiques-dans-une-application-web" data-toc="cas-d-utilisation-typiques-dans-une-application-web">Cas d'Utilisation Typiques dans une Application Web</h2><p id="-a0k1zx_384">Les &eacute;v&eacute;nements sont particuli&egrave;rement utiles dans les applications web pour :</p><ol class="list _decimal" id="-a0k1zx_385" type="1"><li class="list__item" id="-a0k1zx_387"><p id="-a0k1zx_392"><span class="control" id="-a0k1zx_394">Notifications Utilisateur Post-Action:</span></p><ul class="list _bullet" id="-a0k1zx_393"><li class="list__item" id="-a0k1zx_395"><p id="-a0k1zx_398">Envoyer un email de confirmation apr&egrave;s inscription (<code class="code" id="-a0k1zx_399">UserCreationEvent</code>).</p></li><li class="list__item" id="-a0k1zx_396"><p id="-a0k1zx_400">Notifier l'utilisateur qu'une commande a &eacute;t&eacute; exp&eacute;di&eacute;e (<code class="code" id="-a0k1zx_401">OrderShippedEvent</code>).</p></li><li class="list__item" id="-a0k1zx_397"><p id="-a0k1zx_402">Signaler la r&eacute;ussite d'une op&eacute;ration longue (import de donn&eacute;es, g&eacute;n&eacute;ration de rapport).</p></li></ul></li><li class="list__item" id="-a0k1zx_388"><p id="-a0k1zx_403"><span class="control" id="-a0k1zx_405">D&eacute;couplage des T&acirc;ches de Fond:</span></p><ul class="list _bullet" id="-a0k1zx_404"><li class="list__item" id="-a0k1zx_406"><p id="-a0k1zx_409">Apr&egrave;s la mise &agrave; jour d'un produit, d&eacute;clencher une r&eacute;indexation dans un moteur de recherche (<code class="code" id="-a0k1zx_410">ProductUpdatedEvent</code>).</p></li><li class="list__item" id="-a0k1zx_407"><p id="-a0k1zx_411">Invalider des caches sp&eacute;cifiques lorsqu'une donn&eacute;e est modifi&eacute;e (<code class="code" id="-a0k1zx_412">CacheInvalidationEvent</code>).</p></li><li class="list__item" id="-a0k1zx_408"><p id="-a0k1zx_413">Planifier des t&acirc;ches de nettoyage ou de maintenance suite &agrave; certaines actions.</p></li></ul></li><li class="list__item" id="-a0k1zx_389"><p id="-a0k1zx_414"><span class="control" id="-a0k1zx_416">Audit et Journalisation:</span></p><ul class="list _bullet" id="-a0k1zx_415"><li class="list__item" id="-a0k1zx_417"><p id="-a0k1zx_419">Enregistrer des &eacute;v&eacute;nements de s&eacute;curit&eacute; importants (connexion r&eacute;ussie/&eacute;chou&eacute;e, modification de droits) dans un journal d'audit (<code class="code" id="-a0k1zx_420">SecurityAuditEvent</code>).</p></li><li class="list__item" id="-a0k1zx_418"><p id="-a0k1zx_421">Tracer des parcours utilisateurs complexes en enregistrant des &eacute;tapes cl&eacute;s sous forme d'&eacute;v&eacute;nements.</p></li></ul></li><li class="list__item" id="-a0k1zx_390"><p id="-a0k1zx_422"><span class="control" id="-a0k1zx_424">Statistiques et M&eacute;triques:</span></p><ul class="list _bullet" id="-a0k1zx_423"><li class="list__item" id="-a0k1zx_425"><p id="-a0k1zx_426">Incr&eacute;menter des compteurs pour des actions sp&eacute;cifiques (produit ajout&eacute; au panier, article publi&eacute;) en &eacute;coutant les &eacute;v&eacute;nements correspondants.</p></li></ul></li><li class="list__item" id="-a0k1zx_391"><p id="-a0k1zx_427"><span class="control" id="-a0k1zx_429">Int&eacute;gration L&eacute;g&egrave;re (Interne):</span></p><ul class="list _bullet" id="-a0k1zx_428"><li class="list__item" id="-a0k1zx_430"><p id="-a0k1zx_431">Permettre &agrave; diff&eacute;rents modules de l'application de r&eacute;agir aux actions des autres sans d&eacute;pendances directes. Par exemple, un module de gestion de stock r&eacute;agit &agrave; un <code class="code" id="-a0k1zx_432">OrderPlacedEvent</code> du module de commandes.</p></li></ul></li></ol></section><section class="chapter"><h2 id="bonnes-pratiques-et-conseils" data-toc="bonnes-pratiques-et-conseils">Bonnes Pratiques et Conseils</h2><ol class="list _decimal" id="-a0k1zx_433" type="1"><li class="list__item" id="-a0k1zx_435"><p id="-a0k1zx_445"><span class="control" id="-a0k1zx_446">Nommage Clair:</span> Donnez des noms explicites &agrave; vos &eacute;v&eacute;nements (souvent un nom au participe pass&eacute; : <code class="code" id="-a0k1zx_447">OrderCreated</code>, <code class="code" id="-a0k1zx_448">UserLoggedIn</code>).</p></li><li class="list__item" id="-a0k1zx_436"><p id="-a0k1zx_449"><span class="control" id="-a0k1zx_450">Granularit&eacute;:</span> Cr&eacute;ez des &eacute;v&eacute;nements sp&eacute;cifiques plut&ocirc;t qu'un &eacute;v&eacute;nement g&eacute;n&eacute;rique avec un type. <code class="code" id="-a0k1zx_451">UserRegisteredEvent</code> est mieux que <code class="code" id="-a0k1zx_452">SystemEvent(type='USER_REGISTRATION')</code>.</p></li><li class="list__item" id="-a0k1zx_437"><p id="-a0k1zx_453"><span class="control" id="-a0k1zx_454">Immutabilit&eacute;:</span> Rendez les objets &eacute;v&eacute;nements immutables (champs <code class="code" id="-a0k1zx_455">final</code>, pas de setters). Cela &eacute;vite qu'un listener ne modifie l'&eacute;tat de l'&eacute;v&eacute;nement pour les suivants et am&eacute;liore la s&eacute;curit&eacute; des threads.</p></li><li class="list__item" id="-a0k1zx_438"><p id="-a0k1zx_456"><span class="control" id="-a0k1zx_457">Donn&eacute;es Pertinentes:</span> Incluez uniquement les donn&eacute;es n&eacute;cessaires dans l'&eacute;v&eacute;nement. Si le listener a besoin de plus d'informations, il peut utiliser un ID contenu dans l'&eacute;v&eacute;nement pour les r&eacute;cup&eacute;rer via un service. &Eacute;vitez de mettre des entit&eacute;s JPA compl&egrave;tes si seules quelques informations sont utiles, pr&eacute;f&eacute;rez des DTOs ou des IDs.</p></li><li class="list__item" id="-a0k1zx_439"><p id="-a0k1zx_458"><span class="control" id="-a0k1zx_459">Utilisez <code class="code" id="-a0k1zx_461">@TransactionalEventListener</code>:</span> Pour toute action de listener qui d&eacute;pend de la r&eacute;ussite d'une transaction (notifications, mises &agrave; jour externes), privil&eacute;giez <code class="code" id="-a0k1zx_460">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</code>.</p></li><li class="list__item" id="-a0k1zx_440"><p id="-a0k1zx_462"><span class="control" id="-a0k1zx_463">Gestion des Erreurs dans les Listeners:</span> Un listener qui &eacute;choue peut (s'il est synchrone) faire &eacute;chouer l'op&eacute;ration principale ou (s'il est asynchrone ou transactionnel <code class="code" id="-a0k1zx_464">AFTER_COMMIT</code>) &eacute;chouer silencieusement ou logguer une erreur. Pr&eacute;voyez une gestion robuste des erreurs dans les listeners (try-catch, logging, m&eacute;canismes de retry si pertinent).</p></li><li class="list__item" id="-a0k1zx_441"><p id="-a0k1zx_465"><span class="control" id="-a0k1zx_466">Listeners Asynchrones (<code class="code" id="-a0k1zx_468">@Async</code>):</span> Utilisez-les judicieusement pour les t&acirc;ches longues qui ne doivent pas bloquer le thread principal. N'oubliez pas <code class="code" id="-a0k1zx_467">@EnableAsync</code>. Soyez conscient de la gestion des transactions dans les threads s&eacute;par&eacute;s.</p></li><li class="list__item" id="-a0k1zx_442"><p id="-a0k1zx_469"><span class="control" id="-a0k1zx_470">Ordre des Listeners (<code class="code" id="-a0k1zx_472">@Order</code>):</span> Si plusieurs listeners &eacute;coutent le m&ecirc;me &eacute;v&eacute;nement et que leur ordre d'ex&eacute;cution est important (rarement une bonne id&eacute;e, cela r&eacute;introduit un couplage), vous pouvez utiliser l'annotation <code class="code" id="-a0k1zx_471">@Order</code> sur les m&eacute;thodes de listener.</p></li><li class="list__item" id="-a0k1zx_443"><p id="-a0k1zx_473"><span class="control" id="-a0k1zx_474">Testabilit&eacute;:</span> Le d&eacute;couplage facilite les tests. Testez les &eacute;metteurs (v&eacute;rifiez qu'ils publient le bon &eacute;v&eacute;nement) et les listeners (testez leur logique en leur passant un &eacute;v&eacute;nement manuellement) s&eacute;par&eacute;ment. Utilisez les outils de test Spring pour simuler la publication/r&eacute;ception.</p></li><li class="list__item" id="-a0k1zx_444"><p id="-a0k1zx_475"><span class="control" id="-a0k1zx_476">&Eacute;vitez les D&eacute;pendances Cycliques:</span> Ne cr&eacute;ez pas de situations o&ugrave; un listener publie un &eacute;v&eacute;nement qui d&eacute;clenche un autre listener, qui &agrave; son tour publie l'&eacute;v&eacute;nement initial (ou un autre qui revient au premier).</p></li></ol></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="-a0k1zx_477">Le syst&egrave;me d'&eacute;v&eacute;nements de Spring Boot, combin&eacute; aux <code class="code" id="-a0k1zx_478">@TransactionalEventListener</code> et aux <code class="code" id="-a0k1zx_479">@EntityListeners</code> de JPA, offre des outils puissants pour cr&eacute;er des applications web d&eacute;coupl&eacute;es, maintenables et robustes. En comprenant quand et comment utiliser ces m&eacute;canismes, les d&eacute;veloppeurs peuvent s&eacute;parer efficacement les pr&eacute;occupations, g&eacute;rer la coh&eacute;rence transactionnelle des actions secondaires et r&eacute;agir aux changements du cycle de vie des donn&eacute;es, am&eacute;liorant ainsi la qualit&eacute; globale du code. L'utilisation judicieuse des &eacute;v&eacute;nements synchrones, asynchrones et transactionnels permet d'adapter le comportement de l'application aux besoins sp&eacute;cifiques de chaque cas d'usage.</p></section><div class="last-modified">Last modified: 14 mai 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="020-00-la-gestion-des-formulaires.html" class="navigation-links__prev">La gestion des formulaires</a><a href="030-01-controlleradvice.html" class="navigation-links__next">ControllerAdvice</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.js"></script></body></html>