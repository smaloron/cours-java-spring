<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-05-13T07:33:30.059337"><title>Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring</title><script type="application/json" id="virtual-toc-data">[{"id":"introduction-le-probl-me-du-couplage-fort","level":0,"title":"Introduction : Le Problème du Couplage Fort","anchor":"#introduction-le-probl-me-du-couplage-fort"},{"id":"l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di","level":0,"title":"L\u0027Inversion de Contrôle (IoC) et l\u0027Injection de Dépendances (DI)","anchor":"#l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di"},{"id":"les-beans-spring","level":0,"title":"Les Beans Spring","anchor":"#les-beans-spring"},{"id":"m-canismes-d-injection-de-d-pendances","level":0,"title":"Mécanismes d\u0027Injection de Dépendances","anchor":"#m-canismes-d-injection-de-d-pendances"},{"id":"exercices-pratiques","level":0,"title":"Exercices Pratiques","anchor":"#exercices-pratiques"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/003-00-di-ioc.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/003-00-di-ioc.html#webpage",
    "url": "writerside-documentation/003-00-di-ioc.html",
    "name": "Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Help"
}</script><!-- End Schema.org --></head><body data-id="003-00-DI-IoC" data-main-title="Inversion de contrôle et injection de dépendance" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="003-00-DI-IoC" id="003-00-DI-IoC.md">Inversion de contrôle et injection de dépendance</h1><section class="chapter"><h2 id="introduction-le-probl-me-du-couplage-fort" data-toc="introduction-le-probl-me-du-couplage-fort">Introduction : Le Probl&egrave;me du Couplage Fort</h2><p id="bni30w_9">Dans le d&eacute;veloppement logiciel traditionnel, les objets cr&eacute;ent souvent eux-m&ecirc;mes les objets dont ils d&eacute;pendent (leurs d&eacute;pendances).</p><div class="code-block" data-lang="java">
// Exemple SANS Injection de Dépendances
public class NotificationService {

    private EmailService emailService; // Dépendance

    public NotificationService() {
        // Le NotificationService CRÉE LUI-MÊME son EmailService
        this.emailService = new EmailService();
    }

    public void envoyerNotification(
            String message,
            String destinataire
    ) {
        // ... logique de notification ...
        this.emailService.envoyerEmail(message, destinataire);
        // ...
    }
}

public class EmailService {
    public void envoyerEmail(String message, String destinataire) {
        System.out.println(
                &quot;Email envoyé à &quot; + destinataire + &quot;: &quot; + message
        );
    }
}
</div><p id="bni30w_11">Ce mode de fonctionnement cr&eacute;e un <span class="control" id="bni30w_12">couplage fort</span> entre <code class="code" id="bni30w_13">NotificationService</code> et <code class="code" id="bni30w_14">EmailService</code>. Si l'on souhaite remplacer <code class="code" id="bni30w_15">EmailService</code> par <code class="code" id="bni30w_16">SmsService</code>, il faut modifier le code de <code class="code" id="bni30w_17">NotificationService</code>. De plus, tester <code class="code" id="bni30w_18">NotificationService</code> ind&eacute;pendamment de <code class="code" id="bni30w_19">EmailService</code> devient difficile, car une instance r&eacute;elle de <code class="code" id="bni30w_20">EmailService</code> est toujours cr&eacute;&eacute;e.</p></section><section class="chapter"><h2 id="l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di" data-toc="l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di">L'Inversion de Contr&ocirc;le (IoC) et l'Injection de D&eacute;pendances (DI)</h2><p id="bni30w_21"><span class="control" id="bni30w_24">L'Inversion de Contr&ocirc;le (IoC)</span> est un principe de conception o&ugrave; le contr&ocirc;le du flux d'ex&eacute;cution d'un programme (cr&eacute;ation d'objets, appels de m&eacute;thodes) est invers&eacute; : ce n'est plus le code personnalis&eacute; qui appelle des biblioth&egrave;ques ou cr&eacute;e ses d&eacute;pendances, mais un conteneur ou un framework qui se charge de ces aspects.</p><p id="bni30w_22"><span class="control" id="bni30w_25">L'Injection de D&eacute;pendances (DI)</span> est une impl&eacute;mentation sp&eacute;cifique de l'IoC. Au lieu qu'un objet cr&eacute;e ses d&eacute;pendances, celles-ci lui sont fournies (inject&eacute;es) de l'ext&eacute;rieur par le conteneur IoC.</p><section class="chapter"><h3 id="le-conteneur-ioc-de-spring" data-toc="le-conteneur-ioc-de-spring">Le conteneur IoC de Spring</h3><p id="bni30w_26">Le c&oelig;ur de l'injection de d&eacute;pendances dans Spring est le <span class="control" id="bni30w_29">Conteneur IoC</span> (ou conteneur Spring). Son r&ocirc;le principal est de :</p><ol class="list _decimal" id="bni30w_27" type="1"><li class="list__item" id="bni30w_30"><p id="bni30w_34"><span class="control" id="bni30w_35">Instancier</span> les objets (Beans).</p></li><li class="list__item" id="bni30w_31"><p id="bni30w_36"><span class="control" id="bni30w_37">Configurer</span> les objets (par exemple, en injectant les d&eacute;pendances).</p></li><li class="list__item" id="bni30w_32"><p id="bni30w_38"><span class="control" id="bni30w_39">Assembler</span> les d&eacute;pendances entre les objets.</p></li><li class="list__item" id="bni30w_33"><p id="bni30w_40"><span class="control" id="bni30w_41">G&eacute;rer le cycle de vie</span> complet des beans.</p></li></ol><p id="bni30w_28">Dans une application Spring Boot, le conteneur IoC est g&eacute;n&eacute;ralement une instance de <code class="code" id="bni30w_42">ApplicationContext</code>. Il est automatiquement configur&eacute; et lanc&eacute; au d&eacute;marrage de l'application.</p></section></section><section class="chapter"><h2 id="les-beans-spring" data-toc="les-beans-spring">Les Beans Spring</h2><p id="bni30w_43">Un <span class="control" id="bni30w_50">Bean</span> est un objet qui est instanci&eacute;, assembl&eacute; et g&eacute;r&eacute; par le conteneur IoC de Spring. Spring Boot simplifie grandement la d&eacute;claration des beans gr&acirc;ce aux annotations.</p><p id="bni30w_44"><span class="control" id="bni30w_51">Comment d&eacute;clarer un Bean ?</span> Spring Boot utilise le scan de composants (<code class="code" id="bni30w_52">component scanning</code>) pour d&eacute;tecter automatiquement les classes annot&eacute;es et les enregistrer comme beans. Les annotations st&eacute;r&eacute;otypes courantes sont :</p><ul class="list _bullet" id="bni30w_45"><li class="list__item" id="bni30w_53"><p id="bni30w_58"><code class="code" id="bni30w_59">@Component</code>: Annotation g&eacute;n&eacute;rique pour tout composant g&eacute;r&eacute; par Spring.</p></li><li class="list__item" id="bni30w_54"><p id="bni30w_60"><code class="code" id="bni30w_61">@Service</code>: Sp&eacute;cialisation de <code class="code" id="bni30w_62">@Component</code> pour la couche m&eacute;tier/service.</p></li><li class="list__item" id="bni30w_55"><p id="bni30w_63"><code class="code" id="bni30w_64">@Repository</code>: Sp&eacute;cialisation de <code class="code" id="bni30w_65">@Component</code> pour la couche d'acc&egrave;s aux donn&eacute;es (DAO). Ajoute la traduction automatique des exceptions li&eacute;es &agrave; la persistance.</p></li><li class="list__item" id="bni30w_56"><p id="bni30w_66"><code class="code" id="bni30w_67">@Controller</code>/<code class="code" id="bni30w_68">@RestController</code>: Sp&eacute;cialisation de <code class="code" id="bni30w_69">@Component</code> pour la couche web (MVC/API REST).</p></li><li class="list__item" id="bni30w_57"><p id="bni30w_70"><code class="code" id="bni30w_71">@Configuration</code>: Indique qu'une classe d&eacute;clare des d&eacute;finitions de beans via des m&eacute;thodes annot&eacute;es avec <code class="code" id="bni30w_72">@Bean</code>.</p></li></ul><p id="bni30w_46">L'annotation <code class="code" id="bni30w_73">@SpringBootApplication</code> inclut implicitement <code class="code" id="bni30w_74">@ComponentScan</code>, qui demande &agrave; Spring de scanner le package courant et ses sous-packages &agrave; la recherche de ces annotations.</p><p id="bni30w_47"><span class="control" id="bni30w_75">Exemple de d&eacute;claration de Bean :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.service;

import org.springframework.stereotype.Service;

@Service // Déclare cette classe comme un bean Spring de type Service
public class EmailService {

    public void sendEmail(String message, String destinataire) {
        System.out.println(
                &quot;Email envoyé à &quot; + destinataire + &quot;: &quot; + message
        );
    }
}
</div><section class="chapter"><h3 id="autre-m-thode-de-cr-ation-de-bean" data-toc="autre-m-thode-de-cr-ation-de-bean">Autre m&eacute;thode de cr&eacute;ation de bean</h3><p id="bni30w_76"><span class="control" id="bni30w_78">Configuration Java :</span></p><p id="bni30w_77">Utiliser l'annotation <code class="code" id="bni30w_79">@Configuration</code> sur une classe et l'annotation <code class="code" id="bni30w_80">@Bean</code> sur des m&eacute;thodes qui retournent des instances d'objets. Ces m&eacute;thodes d&eacute;finissent explicitement comment cr&eacute;er les beans.</p></section></section><section class="chapter"><h2 id="m-canismes-d-injection-de-d-pendances" data-toc="m-canismes-d-injection-de-d-pendances">M&eacute;canismes d'Injection de D&eacute;pendances</h2><p id="bni30w_81">Spring propose principalement trois fa&ccedil;ons d'injecter des d&eacute;pendances dans un bean :</p><ol class="list _decimal" id="bni30w_82" type="1"><li class="list__item" id="bni30w_92"><p id="bni30w_95"><span class="control" id="bni30w_96">Injection par Constructeur (Recommand&eacute;e)</span></p></li><li class="list__item" id="bni30w_93"><p id="bni30w_97"><span class="control" id="bni30w_98">Injection par Setter</span></p></li><li class="list__item" id="bni30w_94"><p id="bni30w_99"><span class="control" id="bni30w_100">Injection par Champ (D&eacute;conseill&eacute;e)</span></p></li></ol><section class="chapter"><h3 id="injection-par-constructeur" data-toc="injection-par-constructeur">Injection par Constructeur</h3><p id="bni30w_101">C'est la m&eacute;thode <span class="control" id="bni30w_107">privil&eacute;gi&eacute;e et recommand&eacute;e</span> par l'&eacute;quipe Spring. Les d&eacute;pendances sont fournies via les arguments du constructeur de la classe.</p><ul class="list _bullet" id="bni30w_102"><li class="list__item" id="bni30w_108"><p id="bni30w_114"><span class="control" id="bni30w_115">Avantages :</span></p></li><li class="list__item" id="bni30w_109"><p id="bni30w_116">Garantit que l'objet est toujours cr&eacute;&eacute; dans un &eacute;tat coh&eacute;rent (les d&eacute;pendances obligatoires sont fournies &agrave; la cr&eacute;ation).</p></li><li class="list__item" id="bni30w_110"><p id="bni30w_117">Permet de d&eacute;clarer les champs de d&eacute;pendances comme <code class="code" id="bni30w_118">final</code>, favorisant l'immutabilit&eacute;.</p></li><li class="list__item" id="bni30w_111"><p id="bni30w_119">Rend les d&eacute;pendances explicites et claires.</p></li><li class="list__item" id="bni30w_112"><p id="bni30w_120"><span class="control" id="bni30w_121">Inconv&eacute;nients :</span></p></li><li class="list__item" id="bni30w_113"><p id="bni30w_122">Peut conduire &agrave; des constructeurs avec de nombreux param&egrave;tres si un composant a beaucoup de d&eacute;pendances (ce qui peut indiquer un probl&egrave;me de conception - violation du Single Responsibility Principle).</p></li></ul><p id="bni30w_103"><span class="control" id="bni30w_123">Exemple :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.service;

import fr.formation.spring.demo.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service // Déclare cette classe comme un bean de service
public class UserService implements UserServiceInterface {

    // La dépendance vers le repository
    private final UserRepository userRepository;

    // Injection par constructeur
    // @Autowired est optionnel si la classe n'a qu'un seul constructeur 
    // (depuis Spring 4.3)
    @Autowired
    public UserService(UserRepository userRepository) {
        // Le conteneur Spring fournira une instance de UserRepository ici
        this.userRepository = userRepository;
    }

    @Override
    public String getUserDetails(Long userId) {
        // Utilisation de la dépendance injectée
        return &quot;Details for user: &quot; + userRepository.findById(userId);
    }
}
</div><div class="code-block" data-lang="java">
// Interface et Repository (pour la complétude de l'exemple)
package fr.formation.spring.demo.service;

public interface UserServiceInterface {
    String getUserDetails(Long userId);
}
</div><div class="code-block" data-lang="java">
package fr.formation.spring.demo.repository;

import org.springframework.stereotype.Repository;

@Repository // Déclare cette classe comme un bean de repository
public class UserRepository {
    public String findById(Long userId) {
        // Logique simulée pour récupérer un utilisateur
        return &quot;User&quot; + userId;
    }
}
</div></section><section class="chapter"><h3 id="injection-par-setter" data-toc="injection-par-setter">Injection par Setter</h3><p id="bni30w_124">Les d&eacute;pendances sont inject&eacute;es via des m&eacute;thodes <code class="code" id="bni30w_129">setXxx()</code>.</p><ul class="list _bullet" id="bni30w_125"><li class="list__item" id="bni30w_130"><p id="bni30w_137"><span class="control" id="bni30w_138">Avantages :</span></p></li><li class="list__item" id="bni30w_131"><p id="bni30w_139">Permet l'injection de d&eacute;pendances optionnelles.</p></li><li class="list__item" id="bni30w_132"><p id="bni30w_140">Permet la r&eacute;injection ou la reconfiguration (bien que moins courant).</p></li><li class="list__item" id="bni30w_133"><p id="bni30w_141"><span class="control" id="bni30w_142">Inconv&eacute;nients :</span></p></li><li class="list__item" id="bni30w_134"><p id="bni30w_143">L'objet peut &ecirc;tre cr&eacute;&eacute; dans un &eacute;tat incomplet avant que les setters ne soient appel&eacute;s.</p></li><li class="list__item" id="bni30w_135"><p id="bni30w_144">Les d&eacute;pendances ne peuvent pas &ecirc;tre d&eacute;clar&eacute;es <code class="code" id="bni30w_145">final</code>.</p></li><li class="list__item" id="bni30w_136"><p id="bni30w_146">Moins clair sur les d&eacute;pendances obligatoires.</p></li></ul><p id="bni30w_126"><span class="control" id="bni30w_147">Exemple :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.service;

import fr.formation.spring.demo.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class NotificationService {

    private EmailService emailService; // Dépendance optionnelle

    public NotificationService() {
        // Constructeur par défaut
    }

    // Méthode Setter pour l'injection
    @Autowired
    public void setEmailService(EmailService emailService) {
        // Le conteneur Spring appellera cette méthode pour injecter le bean
        this.emailService = emailService;
        System.out.println(&quot;EmailService injected via setter.&quot;);
    }

    public void sendNotification(String message) {
        if (emailService != null) {
            emailService.send(message);
        } else {
            System.out.println(&quot;Cannot send notification: EmailService not available.&quot;);
        }
    }
}
</div><div class="code-block" data-lang="java">
// Service Email (pour l'exemple)
package fr.formation.spring.demo.service;

import org.springframework.stereotype.Component;

@Component // Un autre bean géré par Spring
public class EmailService {
    public void send(String message) {
        System.out.println(&quot;Sending email: &quot; + message);
    }
}
</div></section><section class="chapter"><h3 id="injection-par-champ" data-toc="injection-par-champ">Injection par Champ</h3><p id="bni30w_148">Les d&eacute;pendances sont inject&eacute;es directement dans les champs de la classe.</p><ul class="list _bullet" id="bni30w_149"><li class="list__item" id="bni30w_152"><p id="bni30w_160"><span class="control" id="bni30w_161">Avantages :</span></p></li><li class="list__item" id="bni30w_153"><p id="bni30w_162">Code tr&egrave;s concis.</p></li><li class="list__item" id="bni30w_154"><p id="bni30w_163"><span class="control" id="bni30w_164">Inconv&eacute;nients :</span></p></li><li class="list__item" id="bni30w_155"><p id="bni30w_165"><span class="control" id="bni30w_166">Fortement d&eacute;conseill&eacute;.</span></p></li><li class="list__item" id="bni30w_156"><p id="bni30w_167">Rend le test unitaire plus difficile (n&eacute;cessite la r&eacute;flexion ou l'utilisation du contexte Spring).</p></li><li class="list__item" id="bni30w_157"><p id="bni30w_168">Cache les d&eacute;pendances : il n'est pas &eacute;vident de voir quelles d&eacute;pendances sont n&eacute;cessaires sans inspecter le code et les annotations.</p></li><li class="list__item" id="bni30w_158"><p id="bni30w_169">Viole le principe d'encapsulation.</p></li><li class="list__item" id="bni30w_159"><p id="bni30w_170">Ne permet pas de rendre les champs <code class="code" id="bni30w_171">final</code>.</p></li></ul><p id="bni30w_150"><span class="control" id="bni30w_172">Exemple (&agrave; &eacute;viter) :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.controller;

import fr.formation.spring.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

// Déclare cette classe comme un contrôleur REST 
// (qui est aussi un @Component)
@RestController 
public class UserController {

    // Injection directe dans le champ (déconseillé)
    @Autowired
    private UserService userService;

    @GetMapping(&quot;/user/{id}&quot;)
    public String getUser(@PathVariable(&quot;id&quot;) Long userId) {
        // Utilisation de la dépendance injectée
        return userService.getUserDetails(userId);
    }
}
</div></section><section class="chapter"><h3 id="annotations-cl-s-pour-la-di" data-toc="annotations-cl-s-pour-la-di">Annotations Cl&eacute;s pour la DI</h3><ul class="list _bullet" id="bni30w_173"><li class="list__item" id="bni30w_174"><p id="bni30w_184"><code class="code" id="bni30w_185">@Autowired</code>: Marque un constructeur, un champ, une m&eacute;thode setter ou une m&eacute;thode de configuration pour l'injection automatique de d&eacute;pendances.</p></li><li class="list__item" id="bni30w_175"><p id="bni30w_186"><code class="code" id="bni30w_187">@Component</code>: Annotation g&eacute;n&eacute;rique pour tout composant g&eacute;r&eacute; par Spring.</p></li><li class="list__item" id="bni30w_176"><p id="bni30w_188"><code class="code" id="bni30w_189">@Service</code>: Sp&eacute;cialisation de <code class="code" id="bni30w_190">@Component</code> pour la couche m&eacute;tier (services).</p></li><li class="list__item" id="bni30w_177"><p id="bni30w_191"><code class="code" id="bni30w_192">@Repository</code>: Sp&eacute;cialisation de <code class="code" id="bni30w_193">@Component</code> pour la couche d'acc&egrave;s aux donn&eacute;es (repositories). Souvent associ&eacute;e &agrave; la traduction automatique des exceptions sp&eacute;cifiques au SGBD en exceptions Spring standard (<code class="code" id="bni30w_194">DataAccessException</code>).</p></li><li class="list__item" id="bni30w_178"><p id="bni30w_195"><code class="code" id="bni30w_196">@Controller</code>, <code class="code" id="bni30w_197">@RestController</code>: Sp&eacute;cialisations de <code class="code" id="bni30w_198">@Component</code> pour la couche de pr&eacute;sentation (contr&ocirc;leurs web).</p></li><li class="list__item" id="bni30w_179"><p id="bni30w_199"><code class="code" id="bni30w_200">@Configuration</code>: D&eacute;signe une classe comme source de d&eacute;finitions de beans. Ces classes contiennent des m&eacute;thodes annot&eacute;es avec <code class="code" id="bni30w_201">@Bean</code>.</p></li><li class="list__item" id="bni30w_180"><p id="bni30w_202"><code class="code" id="bni30w_203">@Bean</code>: Appliqu&eacute;e &agrave; une m&eacute;thode dans une classe <code class="code" id="bni30w_204">@Configuration</code>, indique que la m&eacute;thode instancie, configure et initialise un nouvel objet &agrave; g&eacute;rer par le conteneur Spring. L'objet retourn&eacute; est enregistr&eacute; comme un bean.</p></li><li class="list__item" id="bni30w_181"><p id="bni30w_205"><code class="code" id="bni30w_206">@Qualifier(&quot;beanName&quot;)</code>: Utilis&eacute;e conjointement avec <code class="code" id="bni30w_207">@Autowired</code> pour lever l'ambigu&iuml;t&eacute; lorsqu'il existe plusieurs beans du m&ecirc;me type. Permet de sp&eacute;cifier quel bean pr&eacute;cis doit &ecirc;tre inject&eacute; par son nom.</p></li><li class="list__item" id="bni30w_182"><p id="bni30w_208"><code class="code" id="bni30w_209">@Primary</code>: Indique qu'un bean doit &ecirc;tre prioritaire lorsqu'il existe plusieurs candidats pour une injection automatique. Si aucun <code class="code" id="bni30w_210">@Qualifier</code> n'est sp&eacute;cifi&eacute;, le bean <code class="code" id="bni30w_211">@Primary</code> sera choisi.</p></li><li class="list__item" id="bni30w_183"><p id="bni30w_212"><code class="code" id="bni30w_213">@Scope(&quot;...&quot;)</code>: D&eacute;finit la port&eacute;e (scope) d'un bean (<code class="code" id="bni30w_214">singleton</code>, <code class="code" id="bni30w_215">prototype</code>, <code class="code" id="bni30w_216">request</code>, <code class="code" id="bni30w_217">session</code>, etc.). Par d&eacute;faut, les beans Spring sont des <code class="code" id="bni30w_218">singleton</code>.</p></li></ul></section><section class="chapter"><h3 id="r-solution-d-ambig-it" data-toc="r-solution-d-ambig-it">R&eacute;solution d'Ambig&uuml;it&eacute;</h3><p id="bni30w_219">Que se passe-t-il si plusieurs beans impl&eacute;mentent la m&ecirc;me interface et qu'on tente d'injecter cette interface ?</p><div class="code-block" data-lang="java">
public interface MessageService {
    void sendMessage(String message);
}

@Service(&quot;smsService&quot;) // Nom explicite du bean
public class SmsMessageService implements MessageService {
    @Override
    public void sendMessage(String message) {
        System.out.println(&quot;Sending SMS: &quot; + message);
    }
}

@Service(&quot;emailServiceBean&quot;) // Autre nom explicite
// @Primary // Alternative: Marquer celui-ci comme primaire
public class EmailMessageService implements MessageService {
    @Override
    public void sendMessage(String message) {
        System.out.println(&quot;Sending Email: &quot; + message);
    }
}
</div><p id="bni30w_221">Pour injecter un <code class="code" id="bni30w_224">MessageService</code> sp&eacute;cifique :</p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.consumer;

import fr.formation.spring.demo.service.MessageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class NotificationManager {

    private final MessageService messageService;

    // Injection avec @Qualifier pour spécifier quel bean utiliser
    @Autowired
    public NotificationManager(
            @Qualifier(&quot;smsService&quot;) MessageService messageService
    ) 
    {
        this.messageService = messageService;
    }

    public void notify(String notification) {
        messageService.sendMessage(notification);
    }
}
</div><p id="bni30w_223">Si <code class="code" id="bni30w_225">EmailMessageService</code> &eacute;tait annot&eacute; avec <code class="code" id="bni30w_226">@Primary</code>, une simple injection <code class="code" id="bni30w_227">@Autowired MessageService messageService</code> aurait inject&eacute; <code class="code" id="bni30w_228">EmailMessageService</code> par d&eacute;faut. <code class="code" id="bni30w_229">@Qualifier</code> a priorit&eacute; sur <code class="code" id="bni30w_230">@Primary</code>.</p></section><section class="chapter"><h3 id="configuration-java-avec-configuration-et-bean" data-toc="configuration-java-avec-configuration-et-bean">Configuration Java avec <code class="code" id="bni30w_236">@Configuration</code> et <code class="code" id="bni30w_237">@Bean</code></h3><p id="bni30w_232">Parfois, il n'est pas possible d'annoter directement une classe (par exemple, une classe d'une biblioth&egrave;que tierce) ou la cr&eacute;ation du bean n&eacute;cessite une logique complexe. Dans ce cas, la configuration Java est utilis&eacute;e.</p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.example.external.library.ExternalServiceClient; // Classe externe

@Configuration // Indique que c'est une classe de configuration
public class AppConfig {

    // Définit un bean de type ExternalServiceClient
    @Bean
    public ExternalServiceClient externalServiceClient() {
        // Logique de création et configuration du bean
        ExternalServiceClient client = new ExternalServiceClient();
        client.setApiKey(&quot;VOTRE_CLE_API_ICI&quot;); // Exemple de configuration
        client.setTimeout(5000); // Configuration du timeout en ms
        return client; // L'objet retourné sera géré par Spring
    }

    // On peut injecter d'autres beans dans les méthodes @Bean
    @Bean
    public AnotherService anotherService(ExternalServiceClient client) {
        // Injecte le bean 'externalServiceClient' défini ci-dessus
        return new AnotherService(client);
    }
}
</div><div class="code-block" data-lang="java">
// Classe externe simulée (ne peut pas être annotée avec @Component)
package com.example.external.library;

public class ExternalServiceClient {
    private String apiKey;
    private int timeout;

    // Getters et Setters...
    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }

    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    public void execute() {
        System.out.println(&quot;Executing external service call with key: &quot;
                + apiKey + &quot; and timeout: &quot; + timeout);
    }
}
</div><div class="code-block" data-lang="java">
// Un autre service utilisant le client externe
package fr.formation.spring.demo.service;

import com.example.external.library.ExternalServiceClient;

// Pas besoin de @Service ici si créé via @Bean
public class AnotherService {
    private final ExternalServiceClient externalClient;

    public AnotherService(ExternalServiceClient externalClient) {
        this.externalClient = externalClient;
    }

    public void doSomething() {
        externalClient.execute();
    }
}
</div></section><section class="chapter"><h3 id="port-e-des-beans-scope" data-toc="port-e-des-beans-scope">Port&eacute;e des Beans (Scope)</h3><p id="bni30w_238">Par d&eacute;faut, tous les beans d&eacute;finis dans Spring sont des <span class="control" id="bni30w_243">singletons</span>. Cela signifie qu'une seule instance de ce bean est cr&eacute;&eacute;e par le conteneur Spring et partag&eacute;e dans toute l'application.</p><p id="bni30w_239">Il est possible de changer la port&eacute;e avec l'annotation <code class="code" id="bni30w_244">@Scope</code>:</p><ul class="list _bullet" id="bni30w_240"><li class="list__item" id="bni30w_245"><p id="bni30w_250"><code class="code" id="bni30w_251">@Scope(&quot;singleton&quot;)</code>: (D&eacute;faut) Une seule instance par conteneur IoC.</p></li><li class="list__item" id="bni30w_246"><p id="bni30w_252"><code class="code" id="bni30w_253">@Scope(&quot;prototype&quot;)</code>: Une nouvelle instance est cr&eacute;&eacute;e &agrave; chaque fois que le bean est demand&eacute; (inject&eacute; ou r&eacute;cup&eacute;r&eacute; via <code class="code" id="bni30w_254">getBean()</code>). Spring ne g&egrave;re pas le cycle de vie complet des beans prototype apr&egrave;s leur cr&eacute;ation.</p></li><li class="list__item" id="bni30w_247"><p id="bni30w_255"><code class="code" id="bni30w_256">@Scope(&quot;request&quot;)</code>: (Contexte web) Une instance par requ&ecirc;te HTTP.</p></li><li class="list__item" id="bni30w_248"><p id="bni30w_257"><code class="code" id="bni30w_258">@Scope(&quot;session&quot;)</code>: (Contexte web) Une instance par session HTTP.</p></li><li class="list__item" id="bni30w_249"><p id="bni30w_259"><code class="code" id="bni30w_260">@Scope(&quot;application&quot;)</code>: (Contexte web) Une instance par <code class="code" id="bni30w_261">ServletContext</code>.</p></li></ul><p id="bni30w_241"><span class="control" id="bni30w_262">Exemple de bean prototype :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.util;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Scope(&quot;prototype&quot;) // Chaque injection créera une nouvelle instance
public class RequestTracer {

    private final String creationTimestamp;

    public RequestTracer() {
        this.creationTimestamp = LocalDateTime.now().toString();
        System.out.println(&quot;New RequestTracer created at: &quot;
                + creationTimestamp);
    }

    public String getTimestamp() {
        return creationTimestamp;
    }
}
</div></section><section class="chapter"><h3 id="bonnes-pratiques-et-conseils" data-toc="bonnes-pratiques-et-conseils">Bonnes Pratiques et Conseils</h3><ol class="list _decimal" id="bni30w_263" type="1"><li class="list__item" id="bni30w_264"><p id="bni30w_272"><span class="control" id="bni30w_273">Privil&eacute;gier l'Injection par Constructeur :</span> C'est la m&eacute;thode la plus s&ucirc;re, la plus claire et qui favorise l'immutabilit&eacute;.</p></li><li class="list__item" id="bni30w_265"><p id="bni30w_274"><span class="control" id="bni30w_276">Coder en fonction des Interfaces :</span> Injecter des interfaces plut&ocirc;t que des classes concr&egrave;tes pour un meilleur d&eacute;couplage.</p><div class="code-block" data-lang="java">
// Préférer ceci :
private final CustomerRepository customerRepository;
public MyService(CustomerRepository customerRepository) { ... } 

// Plutôt que cela :
// private final JpaCustomerRepository customerRepository;
// public MyService(JpaCustomerRepository customerRepository) { ... }
</div></li><li class="list__item" id="bni30w_266"><p id="bni30w_277"><span class="control" id="bni30w_278">&Eacute;viter l'Injection par Champ :</span> Pour les raisons de testabilit&eacute; et d'encapsulation mentionn&eacute;es plus haut.</p></li><li class="list__item" id="bni30w_267"><p id="bni30w_279"><span class="control" id="bni30w_280">Utiliser les Annotations St&eacute;r&eacute;otypes Sp&eacute;cifiques :</span> Utiliser <code class="code" id="bni30w_281">@Service</code>, <code class="code" id="bni30w_282">@Repository</code>, <code class="code" id="bni30w_283">@Controller</code> plut&ocirc;t que <code class="code" id="bni30w_284">@Component</code> g&eacute;n&eacute;rique lorsque c'est appropri&eacute;, car elles portent une s&eacute;mantique m&eacute;tier et peuvent activer des fonctionnalit&eacute;s sp&eacute;cifiques (comme la traduction d'exceptions pour <code class="code" id="bni30w_285">@Repository</code>).</p></li><li class="list__item" id="bni30w_268"><p id="bni30w_286"><span class="control" id="bni30w_287">Principe de Responsabilit&eacute; Unique (SRP) :</span> Si une classe a trop de d&eacute;pendances inject&eacute;es via le constructeur, c'est souvent le signe qu'elle en fait trop. Envisager de la d&eacute;couper en composants plus petits et plus cibl&eacute;s.</p></li><li class="list__item" id="bni30w_269"><p id="bni30w_288"><span class="control" id="bni30w_289">Utiliser <code class="code" id="bni30w_290">@Qualifier</code> ou <code class="code" id="bni30w_291">@Primary</code> pour lever les ambigu&iuml;t&eacute;s :</span> Lorsque plusieurs beans du m&ecirc;me type existent.</p></li><li class="list__item" id="bni30w_270"><p id="bni30w_292"><span class="control" id="bni30w_293">Centraliser la Configuration Explicite :</span> Regrouper les d&eacute;finitions <code class="code" id="bni30w_294">@Bean</code> dans des classes <code class="code" id="bni30w_295">@Configuration</code> d&eacute;di&eacute;es (par exemple, <code class="code" id="bni30w_296">PersistenceConfig</code>, <code class="code" id="bni30w_297">WebConfig</code>, <code class="code" id="bni30w_298">IntegrationConfig</code>) pour une meilleure organisation.</p></li><li class="list__item" id="bni30w_271"><p id="bni30w_299"><span class="control" id="bni30w_300">Comprendre les Port&eacute;es (Scopes) :</span> Utiliser la port&eacute;e <code class="code" id="bni30w_301">singleton</code> par d&eacute;faut sauf si un &eacute;tat sp&eacute;cifique par requ&ecirc;te/session ou une nouvelle instance &agrave; chaque fois (<code class="code" id="bni30w_302">prototype</code>) est explicitement n&eacute;cessaire. Attention &agrave; l'injection de beans de port&eacute;e plus courte (ex: <code class="code" id="bni30w_303">request</code>) dans des beans de port&eacute;e plus longue (ex: <code class="code" id="bni30w_304">singleton</code>).</p></li></ol></section><section class="chapter"><h3 id="cas-d-utilisation-typiques" data-toc="cas-d-utilisation-typiques">Cas d'Utilisation Typiques</h3><ul class="list _bullet" id="bni30w_305"><li class="list__item" id="bni30w_307"><p id="bni30w_313"><span class="control" id="bni30w_314">Applications Web :</span> <code class="code" id="bni30w_315">Controller</code> d&eacute;pendant de <code class="code" id="bni30w_316">Service</code>, <code class="code" id="bni30w_317">Service</code> d&eacute;pendant de <code class="code" id="bni30w_318">Repository</code>.</p></li><li class="list__item" id="bni30w_308"><p id="bni30w_319"><span class="control" id="bni30w_320">Acc&egrave;s aux Donn&eacute;es :</span> Injection de <code class="code" id="bni30w_321">DataSource</code>, <code class="code" id="bni30w_322">EntityManagerFactory</code>, <code class="code" id="bni30w_323">JdbcTemplate</code> ou de Repositories sp&eacute;cifiques.</p></li><li class="list__item" id="bni30w_309"><p id="bni30w_324"><span class="control" id="bni30w_325">S&eacute;curit&eacute; :</span> Injection de <code class="code" id="bni30w_326">UserDetailsService</code>, <code class="code" id="bni30w_327">PasswordEncoder</code>, etc.</p></li><li class="list__item" id="bni30w_310"><p id="bni30w_328"><span class="control" id="bni30w_329">Configuration :</span> Injection de valeurs depuis <code class="code" id="bni30w_330">application.properties</code>/<code class="code" id="bni30w_331">yml</code> via <code class="code" id="bni30w_332">@Value</code> ou de beans de configuration (<code class="code" id="bni30w_333">@ConfigurationProperties</code>).</p></li><li class="list__item" id="bni30w_311"><p id="bni30w_334"><span class="control" id="bni30w_335">Int&eacute;gration :</span> Injection de clients pour des services externes (REST, SOAP, messaging queues).</p></li><li class="list__item" id="bni30w_312"><p id="bni30w_336"><span class="control" id="bni30w_337">T&acirc;ches Asynchrones et Planifi&eacute;es :</span> Injection de services dans des beans annot&eacute;s <code class="code" id="bni30w_338">@Async</code> ou <code class="code" id="bni30w_339">@Scheduled</code>.</p></li></ul></section></section><section class="chapter"><h2 id="exercices-pratiques" data-toc="exercices-pratiques">Exercices Pratiques</h2><section class="chapter"><h3 id="exercice-1-injection-par-constructeur-simple" data-toc="exercice-1-injection-par-constructeur-simple">Exercice 1 : Injection par Constructeur Simple</h3><p id="bni30w_343"><span class="control" id="bni30w_347">Objectif :</span> Cr&eacute;er un service simple et l'injecter dans un autre composant via le constructeur.</p><p id="bni30w_344"><span class="control" id="bni30w_348">&Eacute;nonc&eacute; :</span></p><ol class="list _decimal" id="bni30w_345" type="1"><li class="list__item" id="bni30w_349"><p id="bni30w_354">Cr&eacute;ez une interface <code class="code" id="bni30w_355">GreetingService</code> avec une m&eacute;thode <code class="code" id="bni30w_356">String greet(String name)</code>.</p></li><li class="list__item" id="bni30w_350"><p id="bni30w_357">Cr&eacute;ez une classe <code class="code" id="bni30w_358">GreetingServiceImpl</code> qui impl&eacute;mente <code class="code" id="bni30w_359">GreetingService</code>. Cette classe doit retourner &quot; Hello, [name]!&quot;. Annotez-la avec <code class="code" id="bni30w_360">@Service</code>.</p></li><li class="list__item" id="bni30w_351"><p id="bni30w_361">Cr&eacute;ez une classe <code class="code" id="bni30w_362">AppRunner</code> annot&eacute;e avec <code class="code" id="bni30w_363">@Component</code>.</p></li><li class="list__item" id="bni30w_352"><p id="bni30w_364">Injectez <code class="code" id="bni30w_365">GreetingService</code> dans <code class="code" id="bni30w_366">AppRunner</code> en utilisant l'injection par constructeur.</p></li><li class="list__item" id="bni30w_353"><p id="bni30w_367">Dans <code class="code" id="bni30w_368">AppRunner</code>, ajoutez une m&eacute;thode (par exemple, annot&eacute;e <code class="code" id="bni30w_369">@PostConstruct</code> ou impl&eacute;mentant <code class="code" id="bni30w_370">CommandLineRunner</code>) qui utilise le <code class="code" id="bni30w_371">GreetingService</code> inject&eacute; pour afficher &quot;Hello, Spring Boot!&quot; dans la console au d&eacute;marrage.</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-1" data-toc="correction-exercice-1">Correction Exercice 1</h4></div><div class="collapse__content"><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise1;

// 1. Interface
public interface GreetingServiceInterface {
    String greet(String name);
}


</div><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise1;

import org.springframework.stereotype.Service;

// 2. Implémentation du Service
@Service // Bean géré par Spring
public class GreetingServiceImpl implements GreetingServiceInterface {
    @Override
    public String greet(String name) {
        return &quot;Hello, &quot; + name + &quot;!&quot;;
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise1;

import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;
import jakarta.annotation.PostConstruct; // Ou utiliser CommandLineRunner

// 3. Composant Consommateur
@Component
public class AppRunner {

    // Dépendance (interface préférée)
    private final GreetingService greetingService;

    // 4. Injection par Constructeur (@Autowired optionnel ici)
    @Autowired
    public AppRunner(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    // 5. Utilisation de la dépendance
    @PostConstruct // Méthode exécutée après l'injection des dépendances
    public void runAfterStartup() {
        String message = greetingService.greet(&quot;Spring Boot&quot;);
        System.out.println(&quot;Message from GreetingService: &quot; + message);
        // Doit afficher: Message from GreetingService: Hello, Spring Boot!
    }
}
</div></div></div></section></section><section class="chapter"><h3 id="exercice-2-r-solution-d-ambig-it-avec-qualifier" data-toc="exercice-2-r-solution-d-ambig-it-avec-qualifier">Exercice 2 : R&eacute;solution d'Ambig&uuml;it&eacute; avec <code class="code" id="bni30w_382">@Qualifier</code></h3><p id="bni30w_376"><span class="control" id="bni30w_383">Objectif :</span> G&eacute;rer une situation o&ugrave; plusieurs beans impl&eacute;mentent la m&ecirc;me interface.</p><p id="bni30w_377"><span class="control" id="bni30w_384">&Eacute;nonc&eacute; :</span></p><ol class="list _decimal" id="bni30w_378" type="1"><li class="list__item" id="bni30w_385"><p id="bni30w_387">Cr&eacute;ez une interface <code class="code" id="bni30w_388">NotificationSender</code> avec une m&eacute;thode <code class="code" id="bni30w_389">void send(String recipient, String message)</code>.</p></li><li class="list__item" id="bni30w_386"><p id="bni30w_390">Cr&eacute;ez deux impl&eacute;mentations :</p></li></ol><ul class="list _bullet" id="bni30w_379"><li class="list__item" id="bni30w_391"><p id="bni30w_393"><code class="code" id="bni30w_394">EmailNotificationSender</code> annot&eacute;e <code class="code" id="bni30w_395">@Service(&quot;emailNotifier&quot;)</code> qui affiche &quot;Sending email to [recipient]: [message]&quot;.</p></li><li class="list__item" id="bni30w_392"><p id="bni30w_396"><code class="code" id="bni30w_397">SmsNotificationSender</code> annot&eacute;e <code class="code" id="bni30w_398">@Service(&quot;smsNotifier&quot;)</code> qui affiche &quot;Sending SMS to [recipient]: [message]&quot;.</p></li></ul><ol class="list _decimal" id="bni30w_380" type="1" start="3"><li class="list__item" id="bni30w_399"><p id="bni30w_402">Cr&eacute;ez une classe <code class="code" id="bni30w_403">OrderProcessor</code> annot&eacute;e <code class="code" id="bni30w_404">@Component</code>.</p></li><li class="list__item" id="bni30w_400"><p id="bni30w_405">Injectez sp&eacute;cifiquement <code class="code" id="bni30w_406">SmsNotificationSender</code> dans <code class="code" id="bni30w_407">OrderProcessor</code> en utilisant <code class="code" id="bni30w_408">@Qualifier</code> avec l'injection par constructeur.</p></li><li class="list__item" id="bni30w_401"><p id="bni30w_409">Dans <code class="code" id="bni30w_410">OrderProcessor</code>, ajoutez une m&eacute;thode <code class="code" id="bni30w_411">processOrder(String orderId)</code> qui utilise le <code class="code" id="bni30w_412">NotificationSender</code> inject&eacute; pour envoyer une notification (par exemple, &agrave; &quot;Admin&quot; avec le message &quot;Order [orderId] processed.&quot;).</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-2" data-toc="correction-exercice-2">Correction Exercice 2</h4></div><div class="collapse__content"><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise2;

// 1. Interface
public interface NotificationSenderInterface {
    void send(String recipient, String message);
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise2;

import org.springframework.stereotype.Service;

// 2a. Implémentation Email
@Service(&quot;emailNotifier&quot;) // Nom qualifiant le bean
public class EmailNotificationSender implements NotificationSenderInterface {
    @Override
    public void send(String recipient, String message) {
        System.out.println(&quot;Sending email to &quot; + recipient + &quot;: &quot; + message);
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise2;

import org.springframework.stereotype.Service;

// 2b. Implémentation SMS
@Service(&quot;smsNotifier&quot;) // Autre nom qualifiant
public class SmsNotificationSender implements NotificationSenderInterface {
    @Override
    public void send(String recipient, String message) {
        System.out.println(&quot;Sending SMS to &quot; + recipient + &quot;: &quot; + message);
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise2;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import jakarta.annotation.PostConstruct;

// 3. Composant Consommateur
@Component
public class OrderProcessor {

    private final NotificationSender notificationSender;

    // 4. Injection spécifique avec @Qualifier
    @Autowired
    public OrderProcessor(
            @Qualifier(&quot;smsNotifier&quot;) NotificationSenderInterface notificationSender
    ) {
        this.notificationSender = notificationSender;
    }

    // 5. Utilisation
    public void processOrder(String orderId) {
        String message = &quot;Order &quot; + orderId + &quot; processed.&quot;;
        notificationSender.send(&quot;Admin&quot;, message);
        // Doit afficher: Sending SMS to Admin: Order [orderId] processed.
    }

    // Ajout pour tester facilement (par exemple avec @PostConstruct)
    @PostConstruct
    public void testProcessing() {
        processOrder(&quot;XYZ789&quot;);
    }
}
</div></div></div></section></section><section class="chapter"><h3 id="exercice-3-configuration-java-avec-bean" data-toc="exercice-3-configuration-java-avec-bean">Exercice 3 : Configuration Java avec <code class="code" id="bni30w_422">@Bean</code></h3><p id="bni30w_418"><span class="control" id="bni30w_423">Objectif :</span> D&eacute;finir un bean en utilisant la configuration Java et l'injecter.</p><p id="bni30w_419"><span class="control" id="bni30w_424">&Eacute;nonc&eacute; :</span></p><ol class="list _decimal" id="bni30w_420" type="1"><li class="list__item" id="bni30w_425"><p id="bni30w_431">Cr&eacute;ez une classe simple <code class="code" id="bni30w_432">DataSourceConfig</code> (pas une annotation Spring) avec des propri&eacute;t&eacute;s <code class="code" id="bni30w_433">url</code>, <code class="code" id="bni30w_434">username</code>, <code class="code" id="bni30w_435">password</code> et une m&eacute;thode <code class="code" id="bni30w_436">connect()</code>.</p></li><li class="list__item" id="bni30w_426"><p id="bni30w_437">Cr&eacute;ez une classe de configuration Spring <code class="code" id="bni30w_438">AppConfiguration</code> annot&eacute;e avec <code class="code" id="bni30w_439">@Configuration</code>.</p></li><li class="list__item" id="bni30w_427"><p id="bni30w_440">Dans <code class="code" id="bni30w_441">AppConfiguration</code>, d&eacute;finissez une m&eacute;thode annot&eacute;e avec <code class="code" id="bni30w_442">@Bean</code> qui cr&eacute;e et configure une instance de <code class="code" id="bni30w_443">DataSourceConfig</code> (par exemple, avec des valeurs cod&eacute;es en dur pour l'URL, l'utilisateur et le mot de passe). Donnez le nom &quot;customDataSource&quot; &agrave; ce bean.</p></li><li class="list__item" id="bni30w_428"><p id="bni30w_444">Cr&eacute;ez une classe <code class="code" id="bni30w_445">DatabaseChecker</code> annot&eacute;e avec <code class="code" id="bni30w_446">@Component</code>.</p></li><li class="list__item" id="bni30w_429"><p id="bni30w_447">Injectez le bean <code class="code" id="bni30w_448">DataSourceConfig</code> (cr&eacute;&eacute; via <code class="code" id="bni30w_449">@Bean</code>) dans <code class="code" id="bni30w_450">DatabaseChecker</code> par constructeur.</p></li><li class="list__item" id="bni30w_430"><p id="bni30w_451">Dans <code class="code" id="bni30w_452">DatabaseChecker</code>, ajoutez une m&eacute;thode qui appelle <code class="code" id="bni30w_453">connect()</code> sur l'instance inject&eacute;e.</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-3" data-toc="correction-exercice-3">Correction Exercice 3</h4></div><div class="collapse__content"><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise3.configsource;

// 1. Classe simple (POJO), pas un bean Spring par défaut
public class DataSourceConfig {
    private String url;
    private String username;
    private String password;

    // Getters et Setters (ou constructeur)
    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void connect() {
        System.out.println(&quot;Connecting to database at: &quot; + url
                + &quot; with user: &quot; + username);
        // Simulation de connexion
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise3.config;

import fr.formation.spring.di.exercise3.configsource.DataSourceConfig;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 2. Classe de configuration Spring
@Configuration
public class AppConfiguration {

    // 3. Définition du bean via @Bean
    @Bean(&quot;customDataSource&quot;) // Nom explicite du bean
    public DataSourceConfig dataSourceConfig() {
        DataSourceConfig config = new DataSourceConfig();
        config.setUrl(&quot;jdbc:h2:mem:testdb&quot;); // Valeur exemple
        config.setUsername(&quot;sa&quot;); // Valeur exemple
        config.setPassword(&quot;&quot;); // Valeur exemple
        System.out.println(&quot;DataSourceConfig bean created by @Bean method.&quot;);
        return config; // L'instance retournée devient un bean Spring
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise3.checker;

import fr.formation.spring.di.exercise3.configsource.DataSourceConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import jakarta.annotation.PostConstruct;

// 4. Composant consommateur
@Component
public class DatabaseChecker {

    private final DataSourceConfig dataSourceConfig;

    // 5. Injection du bean créé via @Bean
    // @Qualifier est nécessaire ici si plusieurs beans DataSourceConfig existent,
    // ou si on veut être explicite sur le nom &quot;customDataSource&quot;.
    // Si c'est le seul bean de ce type, @Qualifier est optionnel.
    @Autowired
    public DatabaseChecker(
            @Qualifier(&quot;customDataSource&quot;) DataSourceConfig dataSourceConfig) {
        this.dataSourceConfig = dataSourceConfig;
    }

    // 6. Utilisation
    @PostConstruct
    public void checkConnection() {
        System.out.println(&quot;DatabaseChecker is checking connection...&quot;);
        dataSourceConfig.connect();
        // Doit afficher: Connecting to database at: jdbc:h2:mem:testdb with user: sa
    }
}
</div></div></div></section></section></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="bni30w_457">L'injection de d&eacute;pendances est un pilier de Spring et Spring Boot. Sa ma&icirc;trise permet de construire des applications modulaires, testables et faciles &agrave; maintenir. En comprenant les diff&eacute;rents types d'injection, les annotations cl&eacute;s, la r&eacute;solution d'ambigu&iuml;t&eacute; et la configuration Java, les d&eacute;veloppeurs peuvent exploiter pleinement la puissance du conteneur IoC de Spring pour g&eacute;rer efficacement les composants de leur application. L'adoption des bonnes pratiques, notamment la pr&eacute;f&eacute;rence pour l'injection par constructeur et le codage par interface, est essentielle pour b&eacute;n&eacute;ficier au maximum des avantages de la DI.</p><p id="bni30w_458">Pour r&eacute;sumer l'injection de d&eacute;pendance est au c&oelig;ur des bonnes pratiques de d&eacute;veloppement et favorise :</p><ul class="list _bullet" id="bni30w_459"><li class="list__item" id="bni30w_460"><p id="bni30w_463"><span class="control" id="bni30w_464">Le d&eacute;couplage</span> entre les composants.</p></li><li class="list__item" id="bni30w_461"><p id="bni30w_465"><span class="control" id="bni30w_466">La testabilit&eacute;</span> unitaire des classes.</p></li><li class="list__item" id="bni30w_462"><p id="bni30w_467"><span class="control" id="bni30w_468">La flexibilit&eacute;</span> et la maintenabilit&eacute; du code.</p></li></ul></section><div class="last-modified">Last modified: 13 mai 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="002-002-exercices-thymeleaf.html" class="navigation-links__prev">Exercices-thymeleaf</a><a href="003-01-commandline-runner.html" class="navigation-links__next">CommandLine Runner</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.js"></script></body></html>