<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-05-11T08:51:19.812257"><title>Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring</title><script type="application/json" id="virtual-toc-data">[{"id":"introduction-le-probl-me-du-couplage-fort","level":0,"title":"Introduction : Le Problème du Couplage Fort","anchor":"#introduction-le-probl-me-du-couplage-fort"},{"id":"l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di","level":0,"title":"L\u0027Inversion de Contrôle (IoC) et l\u0027Injection de Dépendances (DI)","anchor":"#l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di"},{"id":"les-beans-spring","level":0,"title":"Les Beans Spring","anchor":"#les-beans-spring"},{"id":"m-canismes-d-injection-de-d-pendances","level":0,"title":"Mécanismes d\u0027Injection de Dépendances","anchor":"#m-canismes-d-injection-de-d-pendances"},{"id":"exercices-pratiques","level":0,"title":"Exercices Pratiques","anchor":"#exercices-pratiques"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/003-00-di-ioc.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/003-00-di-ioc.html#webpage",
    "url": "writerside-documentation/003-00-di-ioc.html",
    "name": "Inversion de contr&ocirc;le et injection de d&eacute;pendance | Spring",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Help"
}</script><!-- End Schema.org --></head><body data-id="003-00-DI-IoC" data-main-title="Inversion de contrôle et injection de dépendance" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="003-00-DI-IoC" id="003-00-DI-IoC.md">Inversion de contrôle et injection de dépendance</h1><section class="chapter"><h2 id="introduction-le-probl-me-du-couplage-fort" data-toc="introduction-le-probl-me-du-couplage-fort">Introduction : Le Probl&egrave;me du Couplage Fort</h2><p id="-aow6se_9">Dans le d&eacute;veloppement logiciel traditionnel, les objets cr&eacute;ent souvent eux-m&ecirc;mes les objets dont ils d&eacute;pendent (leurs d&eacute;pendances).</p><div class="code-block" data-lang="java">
// Exemple SANS Injection de Dépendances
public class NotificationService {

    private EmailService emailService; // Dépendance

    public NotificationService() {
        // Le NotificationService CRÉE LUI-MÊME son EmailService
        this.emailService = new EmailService();
    }

    public void envoyerNotification(
            String message,
            String destinataire
    ) {
        // ... logique de notification ...
        this.emailService.envoyerEmail(message, destinataire);
        // ...
    }
}

public class EmailService {
    public void envoyerEmail(String message, String destinataire) {
        System.out.println(
                &quot;Email envoyé à &quot; + destinataire + &quot;: &quot; + message
        );
    }
}
</div><p id="-aow6se_11">Ce mode de fonctionnement cr&eacute;e un <span class="control" id="-aow6se_12">couplage fort</span> entre <code class="code" id="-aow6se_13">NotificationService</code> et <code class="code" id="-aow6se_14">EmailService</code>. Si l'on souhaite remplacer <code class="code" id="-aow6se_15">EmailService</code> par <code class="code" id="-aow6se_16">SmsService</code>, il faut modifier le code de <code class="code" id="-aow6se_17">NotificationService</code>. De plus, tester <code class="code" id="-aow6se_18">NotificationService</code> ind&eacute;pendamment de <code class="code" id="-aow6se_19">EmailService</code> devient difficile, car une instance r&eacute;elle de <code class="code" id="-aow6se_20">EmailService</code> est toujours cr&eacute;&eacute;e.</p></section><section class="chapter"><h2 id="l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di" data-toc="l-inversion-de-contr-le-ioc-et-l-injection-de-d-pendances-di">L'Inversion de Contr&ocirc;le (IoC) et l'Injection de D&eacute;pendances (DI)</h2><p id="-aow6se_21"><span class="control" id="-aow6se_24">L'Inversion de Contr&ocirc;le (IoC)</span> est un principe de conception o&ugrave; le contr&ocirc;le du flux d'ex&eacute;cution d'un programme (cr&eacute;ation d'objets, appels de m&eacute;thodes) est invers&eacute; : ce n'est plus le code personnalis&eacute; qui appelle des biblioth&egrave;ques ou cr&eacute;e ses d&eacute;pendances, mais un conteneur ou un framework qui se charge de ces aspects.</p><p id="-aow6se_22"><span class="control" id="-aow6se_25">L'Injection de D&eacute;pendances (DI)</span> est une impl&eacute;mentation sp&eacute;cifique de l'IoC. Au lieu qu'un objet cr&eacute;e ses d&eacute;pendances, celles-ci lui sont fournies (inject&eacute;es) de l'ext&eacute;rieur par le conteneur IoC.</p><section class="chapter"><h3 id="le-conteneur-ioc-de-spring" data-toc="le-conteneur-ioc-de-spring">Le conteneur IoC de Spring</h3><p id="-aow6se_26">Le c&oelig;ur de l'injection de d&eacute;pendances dans Spring est le <span class="control" id="-aow6se_29">Conteneur IoC</span> (ou conteneur Spring). Son r&ocirc;le principal est de :</p><ol class="list _decimal" id="-aow6se_27" type="1"><li class="list__item" id="-aow6se_30"><p id="-aow6se_34"><span class="control" id="-aow6se_35">Instancier</span> les objets (Beans).</p></li><li class="list__item" id="-aow6se_31"><p id="-aow6se_36"><span class="control" id="-aow6se_37">Configurer</span> les objets (par exemple, en injectant les d&eacute;pendances).</p></li><li class="list__item" id="-aow6se_32"><p id="-aow6se_38"><span class="control" id="-aow6se_39">Assembler</span> les d&eacute;pendances entre les objets.</p></li><li class="list__item" id="-aow6se_33"><p id="-aow6se_40"><span class="control" id="-aow6se_41">G&eacute;rer le cycle de vie</span> complet des beans.</p></li></ol><p id="-aow6se_28">Dans une application Spring Boot, le conteneur IoC est g&eacute;n&eacute;ralement une instance de <code class="code" id="-aow6se_42">ApplicationContext</code>. Il est automatiquement configur&eacute; et lanc&eacute; au d&eacute;marrage de l'application.</p></section></section><section class="chapter"><h2 id="les-beans-spring" data-toc="les-beans-spring">Les Beans Spring</h2><p id="-aow6se_43">Un <span class="control" id="-aow6se_50">Bean</span> est un objet qui est instanci&eacute;, assembl&eacute; et g&eacute;r&eacute; par le conteneur IoC de Spring. Spring Boot simplifie grandement la d&eacute;claration des beans gr&acirc;ce aux annotations.</p><p id="-aow6se_44"><span class="control" id="-aow6se_51">Comment d&eacute;clarer un Bean ?</span> Spring Boot utilise le scan de composants (<code class="code" id="-aow6se_52">component scanning</code>) pour d&eacute;tecter automatiquement les classes annot&eacute;es et les enregistrer comme beans. Les annotations st&eacute;r&eacute;otypes courantes sont :</p><ul class="list _bullet" id="-aow6se_45"><li class="list__item" id="-aow6se_53"><p id="-aow6se_58"><code class="code" id="-aow6se_59">@Component</code>: Annotation g&eacute;n&eacute;rique pour tout composant g&eacute;r&eacute; par Spring.</p></li><li class="list__item" id="-aow6se_54"><p id="-aow6se_60"><code class="code" id="-aow6se_61">@Service</code>: Sp&eacute;cialisation de <code class="code" id="-aow6se_62">@Component</code> pour la couche m&eacute;tier/service.</p></li><li class="list__item" id="-aow6se_55"><p id="-aow6se_63"><code class="code" id="-aow6se_64">@Repository</code>: Sp&eacute;cialisation de <code class="code" id="-aow6se_65">@Component</code> pour la couche d'acc&egrave;s aux donn&eacute;es (DAO). Ajoute la traduction automatique des exceptions li&eacute;es &agrave; la persistance.</p></li><li class="list__item" id="-aow6se_56"><p id="-aow6se_66"><code class="code" id="-aow6se_67">@Controller</code>/<code class="code" id="-aow6se_68">@RestController</code>: Sp&eacute;cialisation de <code class="code" id="-aow6se_69">@Component</code> pour la couche web (MVC/API REST).</p></li><li class="list__item" id="-aow6se_57"><p id="-aow6se_70"><code class="code" id="-aow6se_71">@Configuration</code>: Indique qu'une classe d&eacute;clare des d&eacute;finitions de beans via des m&eacute;thodes annot&eacute;es avec <code class="code" id="-aow6se_72">@Bean</code>.</p></li></ul><p id="-aow6se_46">L'annotation <code class="code" id="-aow6se_73">@SpringBootApplication</code> inclut implicitement <code class="code" id="-aow6se_74">@ComponentScan</code>, qui demande &agrave; Spring de scanner le package courant et ses sous-packages &agrave; la recherche de ces annotations.</p><p id="-aow6se_47"><span class="control" id="-aow6se_75">Exemple de d&eacute;claration de Bean :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.service;

import org.springframework.stereotype.Service;

@Service // Déclare cette classe comme un bean Spring de type Service
public class EmailService {

    public void sendEmail(String message, String destinataire) {
        System.out.println(
                &quot;Email envoyé à &quot; + destinataire + &quot;: &quot; + message
        );
    }
}
</div><section class="chapter"><h3 id="autre-m-thode-de-cr-ation-de-bean" data-toc="autre-m-thode-de-cr-ation-de-bean">Autre m&eacute;thode de cr&eacute;ation de bean</h3><p id="-aow6se_76"><span class="control" id="-aow6se_78">Configuration Java :</span></p><p id="-aow6se_77">Utiliser l'annotation <code class="code" id="-aow6se_79">@Configuration</code> sur une classe et l'annotation <code class="code" id="-aow6se_80">@Bean</code> sur des m&eacute;thodes qui retournent des instances d'objets. Ces m&eacute;thodes d&eacute;finissent explicitement comment cr&eacute;er les beans.</p></section></section><section class="chapter"><h2 id="m-canismes-d-injection-de-d-pendances" data-toc="m-canismes-d-injection-de-d-pendances">M&eacute;canismes d'Injection de D&eacute;pendances</h2><p id="-aow6se_81">Spring propose principalement trois fa&ccedil;ons d'injecter des d&eacute;pendances dans un bean :</p><ol class="list _decimal" id="-aow6se_82" type="1"><li class="list__item" id="-aow6se_92"><p id="-aow6se_95"><span class="control" id="-aow6se_96">Injection par Constructeur (Recommand&eacute;e)</span></p></li><li class="list__item" id="-aow6se_93"><p id="-aow6se_97"><span class="control" id="-aow6se_98">Injection par Setter</span></p></li><li class="list__item" id="-aow6se_94"><p id="-aow6se_99"><span class="control" id="-aow6se_100">Injection par Champ (D&eacute;conseill&eacute;e)</span></p></li></ol><section class="chapter"><h3 id="injection-par-constructeur" data-toc="injection-par-constructeur">Injection par Constructeur</h3><p id="-aow6se_101">C'est la m&eacute;thode <span class="control" id="-aow6se_107">privil&eacute;gi&eacute;e et recommand&eacute;e</span> par l'&eacute;quipe Spring. Les d&eacute;pendances sont fournies via les arguments du constructeur de la classe.</p><ul class="list _bullet" id="-aow6se_102"><li class="list__item" id="-aow6se_108"><p id="-aow6se_114"><span class="control" id="-aow6se_115">Avantages :</span></p></li><li class="list__item" id="-aow6se_109"><p id="-aow6se_116">Garantit que l'objet est toujours cr&eacute;&eacute; dans un &eacute;tat coh&eacute;rent (les d&eacute;pendances obligatoires sont fournies &agrave; la cr&eacute;ation).</p></li><li class="list__item" id="-aow6se_110"><p id="-aow6se_117">Permet de d&eacute;clarer les champs de d&eacute;pendances comme <code class="code" id="-aow6se_118">final</code>, favorisant l'immutabilit&eacute;.</p></li><li class="list__item" id="-aow6se_111"><p id="-aow6se_119">Rend les d&eacute;pendances explicites et claires.</p></li><li class="list__item" id="-aow6se_112"><p id="-aow6se_120"><span class="control" id="-aow6se_121">Inconv&eacute;nients :</span></p></li><li class="list__item" id="-aow6se_113"><p id="-aow6se_122">Peut conduire &agrave; des constructeurs avec de nombreux param&egrave;tres si un composant a beaucoup de d&eacute;pendances (ce qui peut indiquer un probl&egrave;me de conception - violation du Single Responsibility Principle).</p></li></ul><p id="-aow6se_103"><span class="control" id="-aow6se_123">Exemple :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.service;

import fr.formation.spring.demo.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service // Déclare cette classe comme un bean de service
public class UserService implements UserServiceInterface {

    // La dépendance vers le repository
    private final UserRepository userRepository;

    // Injection par constructeur
    // @Autowired est optionnel si la classe n'a qu'un seul constructeur 
    // (depuis Spring 4.3)
    @Autowired
    public UserService(UserRepository userRepository) {
        // Le conteneur Spring fournira une instance de UserRepository ici
        this.userRepository = userRepository;
    }

    @Override
    public String getUserDetails(Long userId) {
        // Utilisation de la dépendance injectée
        return &quot;Details for user: &quot; + userRepository.findById(userId);
    }
}
</div><div class="code-block" data-lang="java">
// Interface et Repository (pour la complétude de l'exemple)
package fr.formation.spring.demo.service;

public interface UserServiceInterface {
    String getUserDetails(Long userId);
}
</div><div class="code-block" data-lang="java">
package fr.formation.spring.demo.repository;

import org.springframework.stereotype.Repository;

@Repository // Déclare cette classe comme un bean de repository
public class UserRepository {
    public String findById(Long userId) {
        // Logique simulée pour récupérer un utilisateur
        return &quot;User&quot; + userId;
    }
}
</div></section><section class="chapter"><h3 id="injection-par-setter" data-toc="injection-par-setter">Injection par Setter</h3><p id="-aow6se_124">Les d&eacute;pendances sont inject&eacute;es via des m&eacute;thodes <code class="code" id="-aow6se_129">setXxx()</code>.</p><ul class="list _bullet" id="-aow6se_125"><li class="list__item" id="-aow6se_130"><p id="-aow6se_137"><span class="control" id="-aow6se_138">Avantages :</span></p></li><li class="list__item" id="-aow6se_131"><p id="-aow6se_139">Permet l'injection de d&eacute;pendances optionnelles.</p></li><li class="list__item" id="-aow6se_132"><p id="-aow6se_140">Permet la r&eacute;injection ou la reconfiguration (bien que moins courant).</p></li><li class="list__item" id="-aow6se_133"><p id="-aow6se_141"><span class="control" id="-aow6se_142">Inconv&eacute;nients :</span></p></li><li class="list__item" id="-aow6se_134"><p id="-aow6se_143">L'objet peut &ecirc;tre cr&eacute;&eacute; dans un &eacute;tat incomplet avant que les setters ne soient appel&eacute;s.</p></li><li class="list__item" id="-aow6se_135"><p id="-aow6se_144">Les d&eacute;pendances ne peuvent pas &ecirc;tre d&eacute;clar&eacute;es <code class="code" id="-aow6se_145">final</code>.</p></li><li class="list__item" id="-aow6se_136"><p id="-aow6se_146">Moins clair sur les d&eacute;pendances obligatoires.</p></li></ul><p id="-aow6se_126"><span class="control" id="-aow6se_147">Exemple :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.service;

import fr.formation.spring.demo.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class NotificationService {

    private EmailService emailService; // Dépendance optionnelle

    public NotificationService() {
        // Constructeur par défaut
    }

    // Méthode Setter pour l'injection
    @Autowired
    public void setEmailService(EmailService emailService) {
        // Le conteneur Spring appellera cette méthode pour injecter le bean
        this.emailService = emailService;
        System.out.println(&quot;EmailService injected via setter.&quot;);
    }

    public void sendNotification(String message) {
        if (emailService != null) {
            emailService.send(message);
        } else {
            System.out.println(&quot;Cannot send notification: EmailService not available.&quot;);
        }
    }
}
</div><div class="code-block" data-lang="java">
// Service Email (pour l'exemple)
package fr.formation.spring.demo.service;

import org.springframework.stereotype.Component;

@Component // Un autre bean géré par Spring
public class EmailService {
    public void send(String message) {
        System.out.println(&quot;Sending email: &quot; + message);
    }
}
</div></section><section class="chapter"><h3 id="injection-par-champ" data-toc="injection-par-champ">Injection par Champ</h3><p id="-aow6se_148">Les d&eacute;pendances sont inject&eacute;es directement dans les champs de la classe.</p><ul class="list _bullet" id="-aow6se_149"><li class="list__item" id="-aow6se_152"><p id="-aow6se_160"><span class="control" id="-aow6se_161">Avantages :</span></p></li><li class="list__item" id="-aow6se_153"><p id="-aow6se_162">Code tr&egrave;s concis.</p></li><li class="list__item" id="-aow6se_154"><p id="-aow6se_163"><span class="control" id="-aow6se_164">Inconv&eacute;nients :</span></p></li><li class="list__item" id="-aow6se_155"><p id="-aow6se_165"><span class="control" id="-aow6se_166">Fortement d&eacute;conseill&eacute;.</span></p></li><li class="list__item" id="-aow6se_156"><p id="-aow6se_167">Rend le test unitaire plus difficile (n&eacute;cessite la r&eacute;flexion ou l'utilisation du contexte Spring).</p></li><li class="list__item" id="-aow6se_157"><p id="-aow6se_168">Cache les d&eacute;pendances : il n'est pas &eacute;vident de voir quelles d&eacute;pendances sont n&eacute;cessaires sans inspecter le code et les annotations.</p></li><li class="list__item" id="-aow6se_158"><p id="-aow6se_169">Viole le principe d'encapsulation.</p></li><li class="list__item" id="-aow6se_159"><p id="-aow6se_170">Ne permet pas de rendre les champs <code class="code" id="-aow6se_171">final</code>.</p></li></ul><p id="-aow6se_150"><span class="control" id="-aow6se_172">Exemple (&agrave; &eacute;viter) :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.controller;

import fr.formation.spring.demo.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

// Déclare cette classe comme un contrôleur REST 
// (qui est aussi un @Component)
@RestController 
public class UserController {

    // Injection directe dans le champ (déconseillé)
    @Autowired
    private UserService userService;

    @GetMapping(&quot;/user/{id}&quot;)
    public String getUser(@PathVariable(&quot;id&quot;) Long userId) {
        // Utilisation de la dépendance injectée
        return userService.getUserDetails(userId);
    }
}
</div></section><section class="chapter"><h3 id="annotations-cl-s-pour-la-di" data-toc="annotations-cl-s-pour-la-di">Annotations Cl&eacute;s pour la DI</h3><ul class="list _bullet" id="-aow6se_173"><li class="list__item" id="-aow6se_174"><p id="-aow6se_184"><code class="code" id="-aow6se_185">@Autowired</code>: Marque un constructeur, un champ, une m&eacute;thode setter ou une m&eacute;thode de configuration pour l'injection automatique de d&eacute;pendances.</p></li><li class="list__item" id="-aow6se_175"><p id="-aow6se_186"><code class="code" id="-aow6se_187">@Component</code>: Annotation g&eacute;n&eacute;rique pour tout composant g&eacute;r&eacute; par Spring.</p></li><li class="list__item" id="-aow6se_176"><p id="-aow6se_188"><code class="code" id="-aow6se_189">@Service</code>: Sp&eacute;cialisation de <code class="code" id="-aow6se_190">@Component</code> pour la couche m&eacute;tier (services).</p></li><li class="list__item" id="-aow6se_177"><p id="-aow6se_191"><code class="code" id="-aow6se_192">@Repository</code>: Sp&eacute;cialisation de <code class="code" id="-aow6se_193">@Component</code> pour la couche d'acc&egrave;s aux donn&eacute;es (repositories). Souvent associ&eacute;e &agrave; la traduction automatique des exceptions sp&eacute;cifiques au SGBD en exceptions Spring standard (<code class="code" id="-aow6se_194">DataAccessException</code>).</p></li><li class="list__item" id="-aow6se_178"><p id="-aow6se_195"><code class="code" id="-aow6se_196">@Controller</code>, <code class="code" id="-aow6se_197">@RestController</code>: Sp&eacute;cialisations de <code class="code" id="-aow6se_198">@Component</code> pour la couche de pr&eacute;sentation (contr&ocirc;leurs web).</p></li><li class="list__item" id="-aow6se_179"><p id="-aow6se_199"><code class="code" id="-aow6se_200">@Configuration</code>: D&eacute;signe une classe comme source de d&eacute;finitions de beans. Ces classes contiennent des m&eacute;thodes annot&eacute;es avec <code class="code" id="-aow6se_201">@Bean</code>.</p></li><li class="list__item" id="-aow6se_180"><p id="-aow6se_202"><code class="code" id="-aow6se_203">@Bean</code>: Appliqu&eacute;e &agrave; une m&eacute;thode dans une classe <code class="code" id="-aow6se_204">@Configuration</code>, indique que la m&eacute;thode instancie, configure et initialise un nouvel objet &agrave; g&eacute;rer par le conteneur Spring. L'objet retourn&eacute; est enregistr&eacute; comme un bean.</p></li><li class="list__item" id="-aow6se_181"><p id="-aow6se_205"><code class="code" id="-aow6se_206">@Qualifier(&quot;beanName&quot;)</code>: Utilis&eacute;e conjointement avec <code class="code" id="-aow6se_207">@Autowired</code> pour lever l'ambigu&iuml;t&eacute; lorsqu'il existe plusieurs beans du m&ecirc;me type. Permet de sp&eacute;cifier quel bean pr&eacute;cis doit &ecirc;tre inject&eacute; par son nom.</p></li><li class="list__item" id="-aow6se_182"><p id="-aow6se_208"><code class="code" id="-aow6se_209">@Primary</code>: Indique qu'un bean doit &ecirc;tre prioritaire lorsqu'il existe plusieurs candidats pour une injection automatique. Si aucun <code class="code" id="-aow6se_210">@Qualifier</code> n'est sp&eacute;cifi&eacute;, le bean <code class="code" id="-aow6se_211">@Primary</code> sera choisi.</p></li><li class="list__item" id="-aow6se_183"><p id="-aow6se_212"><code class="code" id="-aow6se_213">@Scope(&quot;...&quot;)</code>: D&eacute;finit la port&eacute;e (scope) d'un bean (<code class="code" id="-aow6se_214">singleton</code>, <code class="code" id="-aow6se_215">prototype</code>, <code class="code" id="-aow6se_216">request</code>, <code class="code" id="-aow6se_217">session</code>, etc.). Par d&eacute;faut, les beans Spring sont des <code class="code" id="-aow6se_218">singleton</code>.</p></li></ul></section><section class="chapter"><h3 id="r-solution-d-ambig-it" data-toc="r-solution-d-ambig-it">R&eacute;solution d'Ambig&uuml;it&eacute;</h3><p id="-aow6se_219">Que se passe-t-il si plusieurs beans impl&eacute;mentent la m&ecirc;me interface et qu'on tente d'injecter cette interface ?</p><div class="code-block" data-lang="java">
public interface MessageService {
    void sendMessage(String message);
}

@Service(&quot;smsService&quot;) // Nom explicite du bean
public class SmsMessageService implements MessageService {
    @Override
    public void sendMessage(String message) {
        System.out.println(&quot;Sending SMS: &quot; + message);
    }
}

@Service(&quot;emailServiceBean&quot;) // Autre nom explicite
// @Primary // Alternative: Marquer celui-ci comme primaire
public class EmailMessageService implements MessageService {
    @Override
    public void sendMessage(String message) {
        System.out.println(&quot;Sending Email: &quot; + message);
    }
}
</div><p id="-aow6se_221">Pour injecter un <code class="code" id="-aow6se_224">MessageService</code> sp&eacute;cifique :</p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.consumer;

import fr.formation.spring.demo.service.MessageService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class NotificationManager {

    private final MessageService messageService;

    // Injection avec @Qualifier pour spécifier quel bean utiliser
    @Autowired
    public NotificationManager(
            @Qualifier(&quot;smsService&quot;) MessageService messageService
    ) 
    {
        this.messageService = messageService;
    }

    public void notify(String notification) {
        messageService.sendMessage(notification);
    }
}
</div><p id="-aow6se_223">Si <code class="code" id="-aow6se_225">EmailMessageService</code> &eacute;tait annot&eacute; avec <code class="code" id="-aow6se_226">@Primary</code>, une simple injection <code class="code" id="-aow6se_227">@Autowired MessageService messageService</code> aurait inject&eacute; <code class="code" id="-aow6se_228">EmailMessageService</code> par d&eacute;faut. <code class="code" id="-aow6se_229">@Qualifier</code> a priorit&eacute; sur <code class="code" id="-aow6se_230">@Primary</code>.</p></section><section class="chapter"><h3 id="configuration-java-avec-configuration-et-bean" data-toc="configuration-java-avec-configuration-et-bean">Configuration Java avec <code class="code" id="-aow6se_236">@Configuration</code> et <code class="code" id="-aow6se_237">@Bean</code></h3><p id="-aow6se_232">Parfois, il n'est pas possible d'annoter directement une classe (par exemple, une classe d'une biblioth&egrave;que tierce) ou la cr&eacute;ation du bean n&eacute;cessite une logique complexe. Dans ce cas, la configuration Java est utilis&eacute;e.</p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.example.external.library.ExternalServiceClient; // Classe externe

@Configuration // Indique que c'est une classe de configuration
public class AppConfig {

    // Définit un bean de type ExternalServiceClient
    @Bean
    public ExternalServiceClient externalServiceClient() {
        // Logique de création et configuration du bean
        ExternalServiceClient client = new ExternalServiceClient();
        client.setApiKey(&quot;VOTRE_CLE_API_ICI&quot;); // Exemple de configuration
        client.setTimeout(5000); // Configuration du timeout en ms
        return client; // L'objet retourné sera géré par Spring
    }

    // On peut injecter d'autres beans dans les méthodes @Bean
    @Bean
    public AnotherService anotherService(ExternalServiceClient client) {
        // Injecte le bean 'externalServiceClient' défini ci-dessus
        return new AnotherService(client);
    }
}
</div><div class="code-block" data-lang="java">
// Classe externe simulée (ne peut pas être annotée avec @Component)
package com.example.external.library;

public class ExternalServiceClient {
    private String apiKey;
    private int timeout;

    // Getters et Setters...
    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }

    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    public void execute() {
        System.out.println(&quot;Executing external service call with key: &quot;
                + apiKey + &quot; and timeout: &quot; + timeout);
    }
}
</div><div class="code-block" data-lang="java">
// Un autre service utilisant le client externe
package fr.formation.spring.demo.service;

import com.example.external.library.ExternalServiceClient;

// Pas besoin de @Service ici si créé via @Bean
public class AnotherService {
    private final ExternalServiceClient externalClient;

    public AnotherService(ExternalServiceClient externalClient) {
        this.externalClient = externalClient;
    }

    public void doSomething() {
        externalClient.execute();
    }
}
</div></section><section class="chapter"><h3 id="port-e-des-beans-scope" data-toc="port-e-des-beans-scope">Port&eacute;e des Beans (Scope)</h3><p id="-aow6se_238">Par d&eacute;faut, tous les beans d&eacute;finis dans Spring sont des <span class="control" id="-aow6se_243">singletons</span>. Cela signifie qu'une seule instance de ce bean est cr&eacute;&eacute;e par le conteneur Spring et partag&eacute;e dans toute l'application.</p><p id="-aow6se_239">Il est possible de changer la port&eacute;e avec l'annotation <code class="code" id="-aow6se_244">@Scope</code>:</p><ul class="list _bullet" id="-aow6se_240"><li class="list__item" id="-aow6se_245"><p id="-aow6se_250"><code class="code" id="-aow6se_251">@Scope(&quot;singleton&quot;)</code>: (D&eacute;faut) Une seule instance par conteneur IoC.</p></li><li class="list__item" id="-aow6se_246"><p id="-aow6se_252"><code class="code" id="-aow6se_253">@Scope(&quot;prototype&quot;)</code>: Une nouvelle instance est cr&eacute;&eacute;e &agrave; chaque fois que le bean est demand&eacute; (inject&eacute; ou r&eacute;cup&eacute;r&eacute; via <code class="code" id="-aow6se_254">getBean()</code>). Spring ne g&egrave;re pas le cycle de vie complet des beans prototype apr&egrave;s leur cr&eacute;ation.</p></li><li class="list__item" id="-aow6se_247"><p id="-aow6se_255"><code class="code" id="-aow6se_256">@Scope(&quot;request&quot;)</code>: (Contexte web) Une instance par requ&ecirc;te HTTP.</p></li><li class="list__item" id="-aow6se_248"><p id="-aow6se_257"><code class="code" id="-aow6se_258">@Scope(&quot;session&quot;)</code>: (Contexte web) Une instance par session HTTP.</p></li><li class="list__item" id="-aow6se_249"><p id="-aow6se_259"><code class="code" id="-aow6se_260">@Scope(&quot;application&quot;)</code>: (Contexte web) Une instance par <code class="code" id="-aow6se_261">ServletContext</code>.</p></li></ul><p id="-aow6se_241"><span class="control" id="-aow6se_262">Exemple de bean prototype :</span></p><div class="code-block" data-lang="java">
package fr.formation.spring.demo.util;

import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Component
@Scope(&quot;prototype&quot;) // Chaque injection créera une nouvelle instance
public class RequestTracer {

    private final String creationTimestamp;

    public RequestTracer() {
        this.creationTimestamp = LocalDateTime.now().toString();
        System.out.println(&quot;New RequestTracer created at: &quot;
                + creationTimestamp);
    }

    public String getTimestamp() {
        return creationTimestamp;
    }
}
</div></section><section class="chapter"><h3 id="bonnes-pratiques-et-conseils" data-toc="bonnes-pratiques-et-conseils">Bonnes Pratiques et Conseils</h3><ol class="list _decimal" id="-aow6se_263" type="1"><li class="list__item" id="-aow6se_264"><p id="-aow6se_272"><span class="control" id="-aow6se_273">Privil&eacute;gier l'Injection par Constructeur :</span> C'est la m&eacute;thode la plus s&ucirc;re, la plus claire et qui favorise l'immutabilit&eacute;.</p></li><li class="list__item" id="-aow6se_265"><p id="-aow6se_274"><span class="control" id="-aow6se_276">Coder en fonction des Interfaces :</span> Injecter des interfaces plut&ocirc;t que des classes concr&egrave;tes pour un meilleur d&eacute;couplage.</p><div class="code-block" data-lang="java">
// Préférer ceci :
private final CustomerRepository customerRepository;
public MyService(CustomerRepository customerRepository) { ... } 

// Plutôt que cela :
// private final JpaCustomerRepository customerRepository;
// public MyService(JpaCustomerRepository customerRepository) { ... }
</div></li><li class="list__item" id="-aow6se_266"><p id="-aow6se_277"><span class="control" id="-aow6se_278">&Eacute;viter l'Injection par Champ :</span> Pour les raisons de testabilit&eacute; et d'encapsulation mentionn&eacute;es plus haut.</p></li><li class="list__item" id="-aow6se_267"><p id="-aow6se_279"><span class="control" id="-aow6se_280">Utiliser les Annotations St&eacute;r&eacute;otypes Sp&eacute;cifiques :</span> Utiliser <code class="code" id="-aow6se_281">@Service</code>, <code class="code" id="-aow6se_282">@Repository</code>, <code class="code" id="-aow6se_283">@Controller</code> plut&ocirc;t que <code class="code" id="-aow6se_284">@Component</code> g&eacute;n&eacute;rique lorsque c'est appropri&eacute;, car elles portent une s&eacute;mantique m&eacute;tier et peuvent activer des fonctionnalit&eacute;s sp&eacute;cifiques (comme la traduction d'exceptions pour <code class="code" id="-aow6se_285">@Repository</code>).</p></li><li class="list__item" id="-aow6se_268"><p id="-aow6se_286"><span class="control" id="-aow6se_287">Principe de Responsabilit&eacute; Unique (SRP) :</span> Si une classe a trop de d&eacute;pendances inject&eacute;es via le constructeur, c'est souvent le signe qu'elle en fait trop. Envisager de la d&eacute;couper en composants plus petits et plus cibl&eacute;s.</p></li><li class="list__item" id="-aow6se_269"><p id="-aow6se_288"><span class="control" id="-aow6se_289">Utiliser <code class="code" id="-aow6se_290">@Qualifier</code> ou <code class="code" id="-aow6se_291">@Primary</code> pour lever les ambigu&iuml;t&eacute;s :</span> Lorsque plusieurs beans du m&ecirc;me type existent.</p></li><li class="list__item" id="-aow6se_270"><p id="-aow6se_292"><span class="control" id="-aow6se_293">Centraliser la Configuration Explicite :</span> Regrouper les d&eacute;finitions <code class="code" id="-aow6se_294">@Bean</code> dans des classes <code class="code" id="-aow6se_295">@Configuration</code> d&eacute;di&eacute;es (par exemple, <code class="code" id="-aow6se_296">PersistenceConfig</code>, <code class="code" id="-aow6se_297">WebConfig</code>, <code class="code" id="-aow6se_298">IntegrationConfig</code>) pour une meilleure organisation.</p></li><li class="list__item" id="-aow6se_271"><p id="-aow6se_299"><span class="control" id="-aow6se_300">Comprendre les Port&eacute;es (Scopes) :</span> Utiliser la port&eacute;e <code class="code" id="-aow6se_301">singleton</code> par d&eacute;faut sauf si un &eacute;tat sp&eacute;cifique par requ&ecirc;te/session ou une nouvelle instance &agrave; chaque fois (<code class="code" id="-aow6se_302">prototype</code>) est explicitement n&eacute;cessaire. Attention &agrave; l'injection de beans de port&eacute;e plus courte (ex: <code class="code" id="-aow6se_303">request</code>) dans des beans de port&eacute;e plus longue (ex: <code class="code" id="-aow6se_304">singleton</code>).</p></li></ol></section><section class="chapter"><h3 id="cas-d-utilisation-typiques" data-toc="cas-d-utilisation-typiques">Cas d'Utilisation Typiques</h3><ul class="list _bullet" id="-aow6se_305"><li class="list__item" id="-aow6se_307"><p id="-aow6se_313"><span class="control" id="-aow6se_314">Applications Web :</span> <code class="code" id="-aow6se_315">Controller</code> d&eacute;pendant de <code class="code" id="-aow6se_316">Service</code>, <code class="code" id="-aow6se_317">Service</code> d&eacute;pendant de <code class="code" id="-aow6se_318">Repository</code>.</p></li><li class="list__item" id="-aow6se_308"><p id="-aow6se_319"><span class="control" id="-aow6se_320">Acc&egrave;s aux Donn&eacute;es :</span> Injection de <code class="code" id="-aow6se_321">DataSource</code>, <code class="code" id="-aow6se_322">EntityManagerFactory</code>, <code class="code" id="-aow6se_323">JdbcTemplate</code> ou de Repositories sp&eacute;cifiques.</p></li><li class="list__item" id="-aow6se_309"><p id="-aow6se_324"><span class="control" id="-aow6se_325">S&eacute;curit&eacute; :</span> Injection de <code class="code" id="-aow6se_326">UserDetailsService</code>, <code class="code" id="-aow6se_327">PasswordEncoder</code>, etc.</p></li><li class="list__item" id="-aow6se_310"><p id="-aow6se_328"><span class="control" id="-aow6se_329">Configuration :</span> Injection de valeurs depuis <code class="code" id="-aow6se_330">application.properties</code>/<code class="code" id="-aow6se_331">yml</code> via <code class="code" id="-aow6se_332">@Value</code> ou de beans de configuration (<code class="code" id="-aow6se_333">@ConfigurationProperties</code>).</p></li><li class="list__item" id="-aow6se_311"><p id="-aow6se_334"><span class="control" id="-aow6se_335">Int&eacute;gration :</span> Injection de clients pour des services externes (REST, SOAP, messaging queues).</p></li><li class="list__item" id="-aow6se_312"><p id="-aow6se_336"><span class="control" id="-aow6se_337">T&acirc;ches Asynchrones et Planifi&eacute;es :</span> Injection de services dans des beans annot&eacute;s <code class="code" id="-aow6se_338">@Async</code> ou <code class="code" id="-aow6se_339">@Scheduled</code>.</p></li></ul></section></section><section class="chapter"><h2 id="exercices-pratiques" data-toc="exercices-pratiques">Exercices Pratiques</h2><section class="chapter"><h3 id="exercice-1-injection-par-constructeur-simple" data-toc="exercice-1-injection-par-constructeur-simple">Exercice 1 : Injection par Constructeur Simple</h3><p id="-aow6se_343"><span class="control" id="-aow6se_347">Objectif :</span> Cr&eacute;er un service simple et l'injecter dans un autre composant via le constructeur.</p><p id="-aow6se_344"><span class="control" id="-aow6se_348">&Eacute;nonc&eacute; :</span></p><ol class="list _decimal" id="-aow6se_345" type="1"><li class="list__item" id="-aow6se_349"><p id="-aow6se_354">Cr&eacute;ez une interface <code class="code" id="-aow6se_355">GreetingService</code> avec une m&eacute;thode <code class="code" id="-aow6se_356">String greet(String name)</code>.</p></li><li class="list__item" id="-aow6se_350"><p id="-aow6se_357">Cr&eacute;ez une classe <code class="code" id="-aow6se_358">GreetingServiceImpl</code> qui impl&eacute;mente <code class="code" id="-aow6se_359">GreetingService</code>. Cette classe doit retourner &quot; Hello, [name]!&quot;. Annotez-la avec <code class="code" id="-aow6se_360">@Service</code>.</p></li><li class="list__item" id="-aow6se_351"><p id="-aow6se_361">Cr&eacute;ez une classe <code class="code" id="-aow6se_362">AppRunner</code> annot&eacute;e avec <code class="code" id="-aow6se_363">@Component</code>.</p></li><li class="list__item" id="-aow6se_352"><p id="-aow6se_364">Injectez <code class="code" id="-aow6se_365">GreetingService</code> dans <code class="code" id="-aow6se_366">AppRunner</code> en utilisant l'injection par constructeur.</p></li><li class="list__item" id="-aow6se_353"><p id="-aow6se_367">Dans <code class="code" id="-aow6se_368">AppRunner</code>, ajoutez une m&eacute;thode (par exemple, annot&eacute;e <code class="code" id="-aow6se_369">@PostConstruct</code> ou impl&eacute;mentant <code class="code" id="-aow6se_370">CommandLineRunner</code>) qui utilise le <code class="code" id="-aow6se_371">GreetingService</code> inject&eacute; pour afficher &quot;Hello, Spring Boot!&quot; dans la console au d&eacute;marrage.</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-1" data-toc="correction-exercice-1">Correction Exercice 1</h4></div><div class="collapse__content"><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise1;

// 1. Interface
public interface GreetingServiceInterface {
    String greet(String name);
}


</div><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise1;

import org.springframework.stereotype.Service;

// 2. Implémentation du Service
@Service // Bean géré par Spring
public class GreetingServiceImpl implements GreetingServiceInterface {
    @Override
    public String greet(String name) {
        return &quot;Hello, &quot; + name + &quot;!&quot;;
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise1;

import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Autowired;
import jakarta.annotation.PostConstruct; // Ou utiliser CommandLineRunner

// 3. Composant Consommateur
@Component
public class AppRunner {

    // Dépendance (interface préférée)
    private final GreetingService greetingService;

    // 4. Injection par Constructeur (@Autowired optionnel ici)
    @Autowired
    public AppRunner(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    // 5. Utilisation de la dépendance
    @PostConstruct // Méthode exécutée après l'injection des dépendances
    public void runAfterStartup() {
        String message = greetingService.greet(&quot;Spring Boot&quot;);
        System.out.println(&quot;Message from GreetingService: &quot; + message);
        // Doit afficher: Message from GreetingService: Hello, Spring Boot!
    }
}
</div></div></div></section></section><section class="chapter"><h3 id="exercice-2-r-solution-d-ambig-it-avec-qualifier" data-toc="exercice-2-r-solution-d-ambig-it-avec-qualifier">Exercice 2 : R&eacute;solution d'Ambig&uuml;it&eacute; avec <code class="code" id="-aow6se_382">@Qualifier</code></h3><p id="-aow6se_376"><span class="control" id="-aow6se_383">Objectif :</span> G&eacute;rer une situation o&ugrave; plusieurs beans impl&eacute;mentent la m&ecirc;me interface.</p><p id="-aow6se_377"><span class="control" id="-aow6se_384">&Eacute;nonc&eacute; :</span></p><ol class="list _decimal" id="-aow6se_378" type="1"><li class="list__item" id="-aow6se_385"><p id="-aow6se_387">Cr&eacute;ez une interface <code class="code" id="-aow6se_388">NotificationSender</code> avec une m&eacute;thode <code class="code" id="-aow6se_389">void send(String recipient, String message)</code>.</p></li><li class="list__item" id="-aow6se_386"><p id="-aow6se_390">Cr&eacute;ez deux impl&eacute;mentations :</p></li></ol><ul class="list _bullet" id="-aow6se_379"><li class="list__item" id="-aow6se_391"><p id="-aow6se_393"><code class="code" id="-aow6se_394">EmailNotificationSender</code> annot&eacute;e <code class="code" id="-aow6se_395">@Service(&quot;emailNotifier&quot;)</code> qui affiche &quot;Sending email to [recipient]: [message]&quot;.</p></li><li class="list__item" id="-aow6se_392"><p id="-aow6se_396"><code class="code" id="-aow6se_397">SmsNotificationSender</code> annot&eacute;e <code class="code" id="-aow6se_398">@Service(&quot;smsNotifier&quot;)</code> qui affiche &quot;Sending SMS to [recipient]: [message]&quot;.</p></li></ul><ol class="list _decimal" id="-aow6se_380" type="1" start="3"><li class="list__item" id="-aow6se_399"><p id="-aow6se_402">Cr&eacute;ez une classe <code class="code" id="-aow6se_403">OrderProcessor</code> annot&eacute;e <code class="code" id="-aow6se_404">@Component</code>.</p></li><li class="list__item" id="-aow6se_400"><p id="-aow6se_405">Injectez sp&eacute;cifiquement <code class="code" id="-aow6se_406">SmsNotificationSender</code> dans <code class="code" id="-aow6se_407">OrderProcessor</code> en utilisant <code class="code" id="-aow6se_408">@Qualifier</code> avec l'injection par constructeur.</p></li><li class="list__item" id="-aow6se_401"><p id="-aow6se_409">Dans <code class="code" id="-aow6se_410">OrderProcessor</code>, ajoutez une m&eacute;thode <code class="code" id="-aow6se_411">processOrder(String orderId)</code> qui utilise le <code class="code" id="-aow6se_412">NotificationSender</code> inject&eacute; pour envoyer une notification (par exemple, &agrave; &quot;Admin&quot; avec le message &quot;Order [orderId] processed.&quot;).</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-2" data-toc="correction-exercice-2">Correction Exercice 2</h4></div><div class="collapse__content"><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise2;

// 1. Interface
public interface NotificationSenderInterface {
    void send(String recipient, String message);
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise2;

import org.springframework.stereotype.Service;

// 2a. Implémentation Email
@Service(&quot;emailNotifier&quot;) // Nom qualifiant le bean
public class EmailNotificationSender implements NotificationSenderInterface {
    @Override
    public void send(String recipient, String message) {
        System.out.println(&quot;Sending email to &quot; + recipient + &quot;: &quot; + message);
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise2;

import org.springframework.stereotype.Service;

// 2b. Implémentation SMS
@Service(&quot;smsNotifier&quot;) // Autre nom qualifiant
public class SmsNotificationSender implements NotificationSenderInterface {
    @Override
    public void send(String recipient, String message) {
        System.out.println(&quot;Sending SMS to &quot; + recipient + &quot;: &quot; + message);
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise2;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

// 3. Composant Consommateur
@Component
public class OrderProcessor {

    private final NotificationSender notificationSender;

    // 4. Injection spécifique avec @Qualifier
    @Autowired
    public OrderProcessor(
            @Qualifier(&quot;smsNotifier&quot;) NotificationSenderInterface notificationSender
    ) {
        this.notificationSender = notificationSender;
    }

    // 5. Utilisation
    public void processOrder(String orderId) {
        String message = &quot;Order &quot; + orderId + &quot; processed.&quot;;
        notificationSender.send(&quot;Admin&quot;, message);
        // Doit afficher: Sending SMS to Admin: Order [orderId] processed.
    }

    // Ajout pour tester facilement (par exemple avec @PostConstruct)
    @jakarta.annotation.PostConstruct
    public void testProcessing() {
        processOrder(&quot;XYZ789&quot;);
    }
}
</div></div></div></section></section><section class="chapter"><h3 id="exercice-3-configuration-java-avec-bean" data-toc="exercice-3-configuration-java-avec-bean">Exercice 3 : Configuration Java avec <code class="code" id="-aow6se_422">@Bean</code></h3><p id="-aow6se_418"><span class="control" id="-aow6se_423">Objectif :</span> D&eacute;finir un bean en utilisant la configuration Java et l'injecter.</p><p id="-aow6se_419"><span class="control" id="-aow6se_424">&Eacute;nonc&eacute; :</span></p><ol class="list _decimal" id="-aow6se_420" type="1"><li class="list__item" id="-aow6se_425"><p id="-aow6se_431">Cr&eacute;ez une classe simple <code class="code" id="-aow6se_432">DataSourceConfig</code> (pas une annotation Spring) avec des propri&eacute;t&eacute;s <code class="code" id="-aow6se_433">url</code>, <code class="code" id="-aow6se_434">username</code>, <code class="code" id="-aow6se_435">password</code> et une m&eacute;thode <code class="code" id="-aow6se_436">connect()</code>.</p></li><li class="list__item" id="-aow6se_426"><p id="-aow6se_437">Cr&eacute;ez une classe de configuration Spring <code class="code" id="-aow6se_438">AppConfiguration</code> annot&eacute;e avec <code class="code" id="-aow6se_439">@Configuration</code>.</p></li><li class="list__item" id="-aow6se_427"><p id="-aow6se_440">Dans <code class="code" id="-aow6se_441">AppConfiguration</code>, d&eacute;finissez une m&eacute;thode annot&eacute;e avec <code class="code" id="-aow6se_442">@Bean</code> qui cr&eacute;e et configure une instance de <code class="code" id="-aow6se_443">DataSourceConfig</code> (par exemple, avec des valeurs cod&eacute;es en dur pour l'URL, l'utilisateur et le mot de passe). Donnez le nom &quot;customDataSource&quot; &agrave; ce bean.</p></li><li class="list__item" id="-aow6se_428"><p id="-aow6se_444">Cr&eacute;ez une classe <code class="code" id="-aow6se_445">DatabaseChecker</code> annot&eacute;e avec <code class="code" id="-aow6se_446">@Component</code>.</p></li><li class="list__item" id="-aow6se_429"><p id="-aow6se_447">Injectez le bean <code class="code" id="-aow6se_448">DataSourceConfig</code> (cr&eacute;&eacute; via <code class="code" id="-aow6se_449">@Bean</code>) dans <code class="code" id="-aow6se_450">DatabaseChecker</code> par constructeur.</p></li><li class="list__item" id="-aow6se_430"><p id="-aow6se_451">Dans <code class="code" id="-aow6se_452">DatabaseChecker</code>, ajoutez une m&eacute;thode qui appelle <code class="code" id="-aow6se_453">connect()</code> sur l'instance inject&eacute;e.</p></li></ol><section class="chapter"><div class="collapse"><div class="collapse__title"><h4 id="correction-exercice-3" data-toc="correction-exercice-3">Correction Exercice 3</h4></div><div class="collapse__content"><div class="code-block" data-lang="java">
package fr.formation.spring.di.exercise3.configsource;

// 1. Classe simple (POJO), pas un bean Spring par défaut
public class DataSourceConfig {
    private String url;
    private String username;
    private String password;

    // Getters et Setters (ou constructeur)
    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void connect() {
        System.out.println(&quot;Connecting to database at: &quot; + url
                + &quot; with user: &quot; + username);
        // Simulation de connexion
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise3.config;

import fr.formation.spring.di.exercise3.configsource.DataSourceConfig;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 2. Classe de configuration Spring
@Configuration
public class AppConfiguration {

    // 3. Définition du bean via @Bean
    @Bean(&quot;customDataSource&quot;) // Nom explicite du bean
    public DataSourceConfig dataSourceConfig() {
        DataSourceConfig config = new DataSourceConfig();
        config.setUrl(&quot;jdbc:h2:mem:testdb&quot;); // Valeur exemple
        config.setUsername(&quot;sa&quot;); // Valeur exemple
        config.setPassword(&quot;&quot;); // Valeur exemple
        System.out.println(&quot;DataSourceConfig bean created by @Bean method.&quot;);
        return config; // L'instance retournée devient un bean Spring
    }
}

</div><div class="code-block" data-lang="java">

package fr.formation.spring.di.exercise3.checker;

import fr.formation.spring.di.exercise3.configsource.DataSourceConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import jakarta.annotation.PostConstruct;

// 4. Composant consommateur
@Component
public class DatabaseChecker {

    private final DataSourceConfig dataSourceConfig;

    // 5. Injection du bean créé via @Bean
    // @Qualifier est nécessaire ici si plusieurs beans DataSourceConfig existent,
    // ou si on veut être explicite sur le nom &quot;customDataSource&quot;.
    // Si c'est le seul bean de ce type, @Qualifier est optionnel.
    @Autowired
    public DatabaseChecker(
            @Qualifier(&quot;customDataSource&quot;) DataSourceConfig dataSourceConfig) {
        this.dataSourceConfig = dataSourceConfig;
    }

    // 6. Utilisation
    @PostConstruct
    public void checkConnection() {
        System.out.println(&quot;DatabaseChecker is checking connection...&quot;);
        dataSourceConfig.connect();
        // Doit afficher: Connecting to database at: jdbc:h2:mem:testdb with user: sa
    }
}
</div></div></div></section></section></section><section class="chapter"><h2 id="conclusion" data-toc="conclusion">Conclusion</h2><p id="-aow6se_457">L'injection de d&eacute;pendances est un pilier de Spring et Spring Boot. Sa ma&icirc;trise permet de construire des applications modulaires, testables et faciles &agrave; maintenir. En comprenant les diff&eacute;rents types d'injection, les annotations cl&eacute;s, la r&eacute;solution d'ambigu&iuml;t&eacute; et la configuration Java, les d&eacute;veloppeurs peuvent exploiter pleinement la puissance du conteneur IoC de Spring pour g&eacute;rer efficacement les composants de leur application. L'adoption des bonnes pratiques, notamment la pr&eacute;f&eacute;rence pour l'injection par constructeur et le codage par interface, est essentielle pour b&eacute;n&eacute;ficier au maximum des avantages de la DI.</p><p id="-aow6se_458">Pour r&eacute;sumer l'injection de d&eacute;pendance est au c&oelig;ur des bonnes pratiques de d&eacute;veloppement et favorise :</p><ul class="list _bullet" id="-aow6se_459"><li class="list__item" id="-aow6se_460"><p id="-aow6se_463"><span class="control" id="-aow6se_464">Le d&eacute;couplage</span> entre les composants.</p></li><li class="list__item" id="-aow6se_461"><p id="-aow6se_465"><span class="control" id="-aow6se_466">La testabilit&eacute;</span> unitaire des classes.</p></li><li class="list__item" id="-aow6se_462"><p id="-aow6se_467"><span class="control" id="-aow6se_468">La flexibilit&eacute;</span> et la maintenabilit&eacute; du code.</p></li></ul></section><div class="last-modified">Last modified: 11 mai 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="002-002-exercices-thymeleaf.html" class="navigation-links__prev">Exercices-thymeleaf</a><a href="003-01-commandline-runner.html" class="navigation-links__next">CommandLine Runner</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.js"></script></body></html>